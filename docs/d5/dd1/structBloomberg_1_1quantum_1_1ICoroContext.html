<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantumLibrary: Bloomberg::quantum::ICoroContext&lt; RET &gt; Interface Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantumLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d5/d7b/structBloomberg_1_1quantum_1_1ICoroContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bloomberg::quantum::ICoroContext&lt; RET &gt; Interface Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Exposes methods to manipulate the coroutine context.  
 <a href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/db7/quantum__icoro__context_8h_source.html">quantum_icoro_context.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Bloomberg::quantum::ICoroContext&lt; RET &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.png" usemap="#Bloomberg::quantum::ICoroContext_3C_20RET_20_3E_map" alt=""/>
  <map id="Bloomberg::quantum::ICoroContext_3C_20RET_20_3E_map" name="Bloomberg::quantum::ICoroContext_3C_20RET_20_3E_map">
<area href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html" title="Exposes methods to manipulate the coroutine context, especially future wait methods." alt="Bloomberg::quantum::ICoroContextBase" shape="rect" coords="130,56,380,80"/>
<area href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html" title="This interface exposes shared functionality between IThreadContext and ICoroContext." alt="Bloomberg::quantum::IContextBase" shape="rect" coords="0,0,250,24"/>
<area href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html" title="Provides an interface to facilitate &#39;implicit&#39; coroutine yielding within other primitives such as mut..." alt="Bloomberg::quantum::ICoroSync" shape="rect" coords="260,0,510,24"/>
<area href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html" title="Concrete class representing a coroutine or a thread context." alt="Bloomberg::quantum::Context&lt; RET &gt;" shape="rect" coords="130,168,380,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c7bff480885fea5124d7cd781b383a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a9c7bff480885fea5124d7cd781b383a1">ContextTag</a> = <a class="el" href="../../dd/d45/structBloomberg_1_1quantum_1_1CoroContextTag.html">CoroContextTag</a></td></tr>
<tr class="separator:a9c7bff480885fea5124d7cd781b383a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4bb817480a24960e407f6e977ed28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afda4bb817480a24960e407f6e977ed28">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; RET &gt; &gt;</td></tr>
<tr class="separator:afda4bb817480a24960e407f6e977ed28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1bf405803ddb27caea4277c0726890"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afc1bf405803ddb27caea4277c0726890">Impl</a> = <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt;</td></tr>
<tr class="separator:afc1bf405803ddb27caea4277c0726890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html">Bloomberg::quantum::ICoroContextBase</a></td></tr>
<tr class="memitem:aa480ed235fb4eddf594fe5731c54ccab inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#aa480ed235fb4eddf594fe5731c54ccab">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html">ICoroContextBase</a> &gt;</td></tr>
<tr class="separator:aa480ed235fb4eddf594fe5731c54ccab inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1IContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">Bloomberg::quantum::IContextBase</a></td></tr>
<tr class="memitem:ac92e5d294479f777fd01f5621e4f8db9 inherit pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">IContextBase</a> &gt;</td></tr>
<tr class="separator:ac92e5d294479f777fd01f5621e4f8db9 inherit pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ICoroSync')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">Bloomberg::quantum::ICoroSync</a></td></tr>
<tr class="memitem:a109b2c4b7d70d53d48bb640a9d849b29 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">ICoroSync</a> &gt;</td></tr>
<tr class="separator:a109b2c4b7d70d53d48bb640a9d849b29 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a330754e60be65d5ee5f73793c7f86f69"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:a330754e60be65d5ee5f73793c7f86f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69">get</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="memdesc:a330754e60be65d5ee5f73793c7f86f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value associated with this context.  <a href="#a330754e60be65d5ee5f73793c7f86f69">More...</a><br /></td></tr>
<tr class="separator:a330754e60be65d5ee5f73793c7f86f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf7ed9f70bc0123547b6baa6ec7c49"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:a43cf7ed9f70bc0123547b6baa6ec7c49"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a43cf7ed9f70bc0123547b6baa6ec7c49">getRef</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const</td></tr>
<tr class="memdesc:a43cf7ed9f70bc0123547b6baa6ec7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference the future value associated with this context.  <a href="#a43cf7ed9f70bc0123547b6baa6ec7c49">More...</a><br /></td></tr>
<tr class="separator:a43cf7ed9f70bc0123547b6baa6ec7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141e79103170cb9cb0fb0197d8df61e5"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a141e79103170cb9cb0fb0197d8df61e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a141e79103170cb9cb0fb0197d8df61e5">getPrev</a> ()</td></tr>
<tr class="memdesc:a141e79103170cb9cb0fb0197d8df61e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value associated with the previous coroutine context in the continuation chain.  <a href="#a141e79103170cb9cb0fb0197d8df61e5">More...</a><br /></td></tr>
<tr class="separator:a141e79103170cb9cb0fb0197d8df61e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeb2b66b620b208cde57129a9293ec3"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a7aeb2b66b620b208cde57129a9293ec3"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7aeb2b66b620b208cde57129a9293ec3">getPrevRef</a> ()</td></tr>
<tr class="memdesc:a7aeb2b66b620b208cde57129a9293ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to future value associated with the previous coroutine context in the continuation chain.  <a href="#a7aeb2b66b620b208cde57129a9293ec3">More...</a><br /></td></tr>
<tr class="separator:a7aeb2b66b620b208cde57129a9293ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a132655875ac6f07d5242e24d80a8d"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a87a132655875ac6f07d5242e24d80a8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a87a132655875ac6f07d5242e24d80a8d">getAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="memdesc:a87a132655875ac6f07d5242e24d80a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value from the 'num-th' continuation context.  <a href="#a87a132655875ac6f07d5242e24d80a8d">More...</a><br /></td></tr>
<tr class="separator:a87a132655875ac6f07d5242e24d80a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c64853ee6c868f4e83668f17d4efd95"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a3c64853ee6c868f4e83668f17d4efd95"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3c64853ee6c868f4e83668f17d4efd95">getRefAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const</td></tr>
<tr class="memdesc:a3c64853ee6c868f4e83668f17d4efd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the future value from the 'num-th' continuation context.  <a href="#a3c64853ee6c868f4e83668f17d4efd95">More...</a><br /></td></tr>
<tr class="separator:a3c64853ee6c868f4e83668f17d4efd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984eea6da10575adfba1a38d3b09ebd7"><td class="memTemplParams" colspan="2">template&lt;class V , class  = NonBufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:a984eea6da10575adfba1a38d3b09ebd7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a984eea6da10575adfba1a38d3b09ebd7">set</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a984eea6da10575adfba1a38d3b09ebd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the promised value associated with this context.  <a href="#a984eea6da10575adfba1a38d3b09ebd7">More...</a><br /></td></tr>
<tr class="separator:a984eea6da10575adfba1a38d3b09ebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a76d5a8b8d68567bf706f468d69ea2"><td class="memTemplParams" colspan="2">template&lt;class V , class  = BufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:a18a76d5a8b8d68567bf706f468d69ea2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a18a76d5a8b8d68567bf706f468d69ea2">push</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a18a76d5a8b8d68567bf706f468d69ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a single value into the promise buffer.  <a href="#a18a76d5a8b8d68567bf706f468d69ea2">More...</a><br /></td></tr>
<tr class="separator:a18a76d5a8b8d68567bf706f468d69ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dc6b764b01a685e37840a796fe0eb"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:a218dc6b764b01a685e37840a796fe0eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a218dc6b764b01a685e37840a796fe0eb">pull</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, bool &amp;isBufferClosed)</td></tr>
<tr class="memdesc:a218dc6b764b01a685e37840a796fe0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull a single value from the future buffer.  <a href="#a218dc6b764b01a685e37840a796fe0eb">More...</a><br /></td></tr>
<tr class="separator:a218dc6b764b01a685e37840a796fe0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2c171bda51b08ef7bf56f0d4aa5a90"><td class="memTemplParams" colspan="2">template&lt;class V  = RET, class  = BufferRetType&lt;V&gt;&gt; </td></tr>
<tr class="memitem:a7f2c171bda51b08ef7bf56f0d4aa5a90"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7f2c171bda51b08ef7bf56f0d4aa5a90">closeBuffer</a> ()</td></tr>
<tr class="memdesc:a7f2c171bda51b08ef7bf56f0d4aa5a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a promise buffer.  <a href="#a7f2c171bda51b08ef7bf56f0d4aa5a90">More...</a><br /></td></tr>
<tr class="separator:a7f2c171bda51b08ef7bf56f0d4aa5a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fadac955b2b32d87d1b8e505dce39c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a0fadac955b2b32d87d1b8e505dce39c3">getNumCoroutineThreads</a> () const</td></tr>
<tr class="memdesc:a0fadac955b2b32d87d1b8e505dce39c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying coroutine threads as specified in the dispatcher constructor. If -1 was passed than this number essentially indicates the number of cores.  <a href="#a0fadac955b2b32d87d1b8e505dce39c3">More...</a><br /></td></tr>
<tr class="separator:a0fadac955b2b32d87d1b8e505dce39c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efdbf7df3818aec9bc8fd98a5bfc640"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1efdbf7df3818aec9bc8fd98a5bfc640">getNumIoThreads</a> () const</td></tr>
<tr class="memdesc:a1efdbf7df3818aec9bc8fd98a5bfc640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying IO threads as specified in the dispatcher constructor.  <a href="#a1efdbf7df3818aec9bc8fd98a5bfc640">More...</a><br /></td></tr>
<tr class="separator:a1efdbf7df3818aec9bc8fd98a5bfc640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c60ca5034b9d1b19dd7279f3476bbec"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; int, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a9c60ca5034b9d1b19dd7279f3476bbec">getCoroQueueIdRangeForAny</a> () const</td></tr>
<tr class="memdesc:a9c60ca5034b9d1b19dd7279f3476bbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> by the <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html" title="Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main e...">Dispatcher</a>.  <a href="#a9c60ca5034b9d1b19dd7279f3476bbec">More...</a><br /></td></tr>
<tr class="separator:a9c60ca5034b9d1b19dd7279f3476bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e16a0f4dda08ea619bbd3997f31a51e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a7e16a0f4dda08ea619bbd3997f31a51e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e">post</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7e16a0f4dda08ea619bbd3997f31a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a7e16a0f4dda08ea619bbd3997f31a51e">More...</a><br /></td></tr>
<tr class="separator:a7e16a0f4dda08ea619bbd3997f31a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7012d092efbd20c729b3c150facb97bb"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a7012d092efbd20c729b3c150facb97bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7012d092efbd20c729b3c150facb97bb">post</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7012d092efbd20c729b3c150facb97bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a7012d092efbd20c729b3c150facb97bb">More...</a><br /></td></tr>
<tr class="separator:a7012d092efbd20c729b3c150facb97bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4563ab7eb43249f2ad8677935b0b002c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a4563ab7eb43249f2ad8677935b0b002c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">postFirst</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4563ab7eb43249f2ad8677935b0b002c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a4563ab7eb43249f2ad8677935b0b002c">More...</a><br /></td></tr>
<tr class="separator:a4563ab7eb43249f2ad8677935b0b002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca0bf6a7feb401d3f3c82518cf54b06"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a3ca0bf6a7feb401d3f3c82518cf54b06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3ca0bf6a7feb401d3f3c82518cf54b06">postFirst</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3ca0bf6a7feb401d3f3c82518cf54b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a3ca0bf6a7feb401d3f3c82518cf54b06">More...</a><br /></td></tr>
<tr class="separator:a3ca0bf6a7feb401d3f3c82518cf54b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122f96fbe956dcc2205564b1e953d8fc"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a122f96fbe956dcc2205564b1e953d8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc">then</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a122f96fbe956dcc2205564b1e953d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a122f96fbe956dcc2205564b1e953d8fc">More...</a><br /></td></tr>
<tr class="separator:a122f96fbe956dcc2205564b1e953d8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0fd314e1dbc93055a0107c390b8af9"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:abc0fd314e1dbc93055a0107c390b8af9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9">onError</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc0fd314e1dbc93055a0107c390b8af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause.  <a href="#abc0fd314e1dbc93055a0107c390b8af9">More...</a><br /></td></tr>
<tr class="separator:abc0fd314e1dbc93055a0107c390b8af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315aa51f354c959bca0eaee24b90a26e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a315aa51f354c959bca0eaee24b90a26e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e">finally</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a315aa51f354c959bca0eaee24b90a26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.  <a href="#a315aa51f354c959bca0eaee24b90a26e">More...</a><br /></td></tr>
<tr class="separator:a315aa51f354c959bca0eaee24b90a26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2530e5e0231aaba5a2f06315f713300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300">end</a> ()</td></tr>
<tr class="memdesc:ab2530e5e0231aaba5a2f06315f713300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the last method in a continuation chain.  <a href="#ab2530e5e0231aaba5a2f06315f713300">More...</a><br /></td></tr>
<tr class="separator:ab2530e5e0231aaba5a2f06315f713300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa32c808db9c73262f5336b03f2055a"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:aafa32c808db9c73262f5336b03f2055a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#aafa32c808db9c73262f5336b03f2055a">postAsyncIo</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:aafa32c808db9c73262f5336b03f2055a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an IO method to run asynchronously on the IO thread pool.  <a href="#aafa32c808db9c73262f5336b03f2055a">More...</a><br /></td></tr>
<tr class="separator:aafa32c808db9c73262f5336b03f2055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a77b36de1443b63583e4217e33fb62"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a03a77b36de1443b63583e4217e33fb62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a03a77b36de1443b63583e4217e33fb62">postAsyncIo</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a03a77b36de1443b63583e4217e33fb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an IO function to run asynchronously on the IO thread pool.  <a href="#a03a77b36de1443b63583e4217e33fb62">More...</a><br /></td></tr>
<tr class="separator:a03a77b36de1443b63583e4217e33fb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1132ca05b44a667a1e3b1633e02a1b23"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a1132ca05b44a667a1e3b1633e02a1b23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1132ca05b44a667a1e3b1633e02a1b23">forEach</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a1132ca05b44a667a1e3b1633e02a1b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs in parallel.  <a href="#a1132ca05b44a667a1e3b1633e02a1b23">More...</a><br /></td></tr>
<tr class="separator:a1132ca05b44a667a1e3b1633e02a1b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06478eb5360e23d192533370f18154bd"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class INPUT_IT &gt; </td></tr>
<tr class="memitem:a06478eb5360e23d192533370f18154bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a06478eb5360e23d192533370f18154bd">forEach</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a06478eb5360e23d192533370f18154bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel.  <a href="#a06478eb5360e23d192533370f18154bd">More...</a><br /></td></tr>
<tr class="separator:a06478eb5360e23d192533370f18154bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f82d2d74ac1840dbe1332898a86796"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:ab7f82d2d74ac1840dbe1332898a86796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab7f82d2d74ac1840dbe1332898a86796">forEachBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:ab7f82d2d74ac1840dbe1332898a86796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#ab7f82d2d74ac1840dbe1332898a86796">More...</a><br /></td></tr>
<tr class="separator:ab7f82d2d74ac1840dbe1332898a86796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9f2692cfbbb3b3cfbf38d6ec6f75e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET  = int, class INPUT_IT &gt; </td></tr>
<tr class="memitem:a40a9f2692cfbbb3b3cfbf38d6ec6f75e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a40a9f2692cfbbb3b3cfbf38d6ec6f75e">forEachBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a40a9f2692cfbbb3b3cfbf38d6ec6f75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a40a9f2692cfbbb3b3cfbf38d6ec6f75e">More...</a><br /></td></tr>
<tr class="separator:a40a9f2692cfbbb3b3cfbf38d6ec6f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876d52748c66869620cdb9753783a86e"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a876d52748c66869620cdb9753783a86e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e">mapReduce</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a876d52748c66869620cdb9753783a86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of map-reduce functionality.  <a href="#a876d52748c66869620cdb9753783a86e">More...</a><br /></td></tr>
<tr class="separator:a876d52748c66869620cdb9753783a86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26ac90a03f5a15b231732597f0c311e"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:af26ac90a03f5a15b231732597f0c311e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#af26ac90a03f5a15b231732597f0c311e">mapReduce</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:af26ac90a03f5a15b231732597f0c311e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#af26ac90a03f5a15b231732597f0c311e">More...</a><br /></td></tr>
<tr class="separator:af26ac90a03f5a15b231732597f0c311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8065d1270e5205c09720d1faf5307a"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:afa8065d1270e5205c09720d1faf5307a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afa8065d1270e5205c09720d1faf5307a">mapReduceBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:afa8065d1270e5205c09720d1faf5307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO.  <a href="#afa8065d1270e5205c09720d1faf5307a">More...</a><br /></td></tr>
<tr class="separator:afa8065d1270e5205c09720d1faf5307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b21c20bc63231bc2ad1e847079183"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a3d6b21c20bc63231bc2ad1e847079183"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3d6b21c20bc63231bc2ad1e847079183">mapReduceBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a3d6b21c20bc63231bc2ad1e847079183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afa8065d1270e5205c09720d1faf5307a" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#a3d6b21c20bc63231bc2ad1e847079183">More...</a><br /></td></tr>
<tr class="separator:a3d6b21c20bc63231bc2ad1e847079183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0926e2c70ccc27b4234d9c966a4c48"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a7d0926e2c70ccc27b4234d9c966a4c48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7d0926e2c70ccc27b4234d9c966a4c48">post</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a7d0926e2c70ccc27b4234d9c966a4c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d652e9a349be10d4f034bfd85701a6"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a70d652e9a349be10d4f034bfd85701a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a70d652e9a349be10d4f034bfd85701a6">post</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a70d652e9a349be10d4f034bfd85701a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543d671426210cedd613440c4fde74d5"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a543d671426210cedd613440c4fde74d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a543d671426210cedd613440c4fde74d5">postFirst</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a543d671426210cedd613440c4fde74d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b1a065188c41efac3d1deed1357b89"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:ac0b1a065188c41efac3d1deed1357b89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ac0b1a065188c41efac3d1deed1357b89">postFirst</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:ac0b1a065188c41efac3d1deed1357b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f79744d5e5f3d9460024877a0cd07a5"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a8f79744d5e5f3d9460024877a0cd07a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a8f79744d5e5f3d9460024877a0cd07a5">then</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a8f79744d5e5f3d9460024877a0cd07a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1cf14d5eb019962a98578eacb5b8ed"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a1c1cf14d5eb019962a98578eacb5b8ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1c1cf14d5eb019962a98578eacb5b8ed">onError</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a1c1cf14d5eb019962a98578eacb5b8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6fe33799ff3e9175ac7b5a9d3fcbf4"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:adb6fe33799ff3e9175ac7b5a9d3fcbf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#adb6fe33799ff3e9175ac7b5a9d3fcbf4">finally</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:adb6fe33799ff3e9175ac7b5a9d3fcbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67347c09d361d71b2e2b2b3b31f60202"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a67347c09d361d71b2e2b2b3b31f60202"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a67347c09d361d71b2e2b2b3b31f60202">forEach</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="separator:a67347c09d361d71b2e2b2b3b31f60202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0df54e37ad9f6d8719ca56b5545e4a"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a2f0df54e37ad9f6d8719ca56b5545e4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a2f0df54e37ad9f6d8719ca56b5545e4a">forEach</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="separator:a2f0df54e37ad9f6d8719ca56b5545e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec77ae4684f6ff01369199f15bf10f"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a73ec77ae4684f6ff01369199f15bf10f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a73ec77ae4684f6ff01369199f15bf10f">forEachBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="separator:a73ec77ae4684f6ff01369199f15bf10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e972a1d6e6f2d891f0300c32e13ff3"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a72e972a1d6e6f2d891f0300c32e13ff3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a72e972a1d6e6f2d891f0300c32e13ff3">forEachBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="separator:a72e972a1d6e6f2d891f0300c32e13ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946b3473429275faee4dc0a77ea7f9d6"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a946b3473429275faee4dc0a77ea7f9d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a946b3473429275faee4dc0a77ea7f9d6">mapReduce</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="separator:a946b3473429275faee4dc0a77ea7f9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa2559b6617f7f20eb19d7ede69f36"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a18aa2559b6617f7f20eb19d7ede69f36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a18aa2559b6617f7f20eb19d7ede69f36">mapReduce</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="separator:a18aa2559b6617f7f20eb19d7ede69f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd9a82576780fcb50db98f1414e0a73"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:aebd9a82576780fcb50db98f1414e0a73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#aebd9a82576780fcb50db98f1414e0a73">mapReduceBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="separator:aebd9a82576780fcb50db98f1414e0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868683cd9afc1b37d7c5bdb213bdda7"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a3868683cd9afc1b37d7c5bdb213bdda7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3868683cd9afc1b37d7c5bdb213bdda7">mapReduceBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="separator:a3868683cd9afc1b37d7c5bdb213bdda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html">Bloomberg::quantum::ICoroContextBase</a></td></tr>
<tr class="memitem:a6790f4caa9b032241c715803201561f4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a6790f4caa9b032241c715803201561f4">wait</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const =0</td></tr>
<tr class="memdesc:a6790f4caa9b032241c715803201561f4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready.  <a href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a6790f4caa9b032241c715803201561f4">More...</a><br /></td></tr>
<tr class="separator:a6790f4caa9b032241c715803201561f4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07fda0dfbf94d1c611118d0eb77a275 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">virtual std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#ac07fda0dfbf94d1c611118d0eb77a275">waitFor</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, std::chrono::milliseconds timeMs) const =0</td></tr>
<tr class="memdesc:ac07fda0dfbf94d1c611118d0eb77a275 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready for a maximum of 'timeMs' milliseconds.  <a href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#ac07fda0dfbf94d1c611118d0eb77a275">More...</a><br /></td></tr>
<tr class="separator:ac07fda0dfbf94d1c611118d0eb77a275 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd4fbaab81b30ae8a8ef2eaf7978bc inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a3cbd4fbaab81b30ae8a8ef2eaf7978bc">waitAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const =0</td></tr>
<tr class="memdesc:a3cbd4fbaab81b30ae8a8ef2eaf7978bc inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready.  <a href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a3cbd4fbaab81b30ae8a8ef2eaf7978bc">More...</a><br /></td></tr>
<tr class="separator:a3cbd4fbaab81b30ae8a8ef2eaf7978bc inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15581e24f526c0dfa0b3d3d9bb204a1f inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">virtual std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a15581e24f526c0dfa0b3d3d9bb204a1f">waitForAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, std::chrono::milliseconds timeMs) const =0</td></tr>
<tr class="memdesc:a15581e24f526c0dfa0b3d3d9bb204a1f inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready for a maximum of 'timeMs' milliseconds.  <a href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a15581e24f526c0dfa0b3d3d9bb204a1f">More...</a><br /></td></tr>
<tr class="separator:a15581e24f526c0dfa0b3d3d9bb204a1f inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d57113242dd466201d5e62a7b42cf8 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a63d57113242dd466201d5e62a7b42cf8">waitAll</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const =0</td></tr>
<tr class="memdesc:a63d57113242dd466201d5e62a7b42cf8 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures in the continuation chain to be ready.  <a href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a63d57113242dd466201d5e62a7b42cf8">More...</a><br /></td></tr>
<tr class="separator:a63d57113242dd466201d5e62a7b42cf8 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1IContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">Bloomberg::quantum::IContextBase</a></td></tr>
<tr class="memitem:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a39a012af6799019e99e1ab5364bb2c86">~IContextBase</a> ()=default</td></tr>
<tr class="memdesc:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a39a012af6799019e99e1ab5364bb2c86">More...</a><br /></td></tr>
<tr class="separator:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022df5fbd098b18058823ac74e4491d1 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a022df5fbd098b18058823ac74e4491d1">valid</a> () const =0</td></tr>
<tr class="memdesc:a022df5fbd098b18058823ac74e4491d1 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the future object associated with this context has a valid shared state with the corresponding promise.  <a href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a022df5fbd098b18058823ac74e4491d1">More...</a><br /></td></tr>
<tr class="separator:a022df5fbd098b18058823ac74e4491d1 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb482148c731b5b9d6866d7e57f962f inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a5cb482148c731b5b9d6866d7e57f962f">validAt</a> (int num) const =0</td></tr>
<tr class="memdesc:a5cb482148c731b5b9d6866d7e57f962f inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the future object associated with the 'num'-th continuation context is still valid.  <a href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a5cb482148c731b5b9d6866d7e57f962f">More...</a><br /></td></tr>
<tr class="separator:a5cb482148c731b5b9d6866d7e57f962f inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084048c88d90de4f3797f18fb3c5fcc4 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a084048c88d90de4f3797f18fb3c5fcc4">setException</a> (std::exception_ptr ex)=0</td></tr>
<tr class="memdesc:a084048c88d90de4f3797f18fb3c5fcc4 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an exception in the promise associated with the current <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html" title="Exposes methods to manipulate the thread context.">IThreadContext</a> or <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html" title="Exposes methods to manipulate the coroutine context.">ICoroContext</a>.  <a href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a084048c88d90de4f3797f18fb3c5fcc4">More...</a><br /></td></tr>
<tr class="separator:a084048c88d90de4f3797f18fb3c5fcc4 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ICoroSync')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">Bloomberg::quantum::ICoroSync</a></td></tr>
<tr class="memitem:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a870e1b03e0c0b5a2310709310b78379b">~ICoroSync</a> ()=default</td></tr>
<tr class="memdesc:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a870e1b03e0c0b5a2310709310b78379b">More...</a><br /></td></tr>
<tr class="separator:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9639b1f2fad78e3d308bec878a5687f2 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a9639b1f2fad78e3d308bec878a5687f2">setYieldHandle</a> (<a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp;<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a2eca1ca5aa6e819c88a65214289290d4">yield</a>)=0</td></tr>
<tr class="memdesc:a9639b1f2fad78e3d308bec878a5687f2 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the underlying boost::coroutine object so that it can be yielded on.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a9639b1f2fad78e3d308bec878a5687f2">More...</a><br /></td></tr>
<tr class="separator:a9639b1f2fad78e3d308bec878a5687f2 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd376fdf2aa4ffd80ae46f0c87bd3400 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#afd376fdf2aa4ffd80ae46f0c87bd3400">getYieldHandle</a> ()=0</td></tr>
<tr class="memdesc:afd376fdf2aa4ffd80ae46f0c87bd3400 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the underlying boost::coroutine object.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#afd376fdf2aa4ffd80ae46f0c87bd3400">More...</a><br /></td></tr>
<tr class="separator:afd376fdf2aa4ffd80ae46f0c87bd3400 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eca1ca5aa6e819c88a65214289290d4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a2eca1ca5aa6e819c88a65214289290d4">yield</a> ()=0</td></tr>
<tr class="memdesc:a2eca1ca5aa6e819c88a65214289290d4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly yields this coroutine context.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a2eca1ca5aa6e819c88a65214289290d4">More...</a><br /></td></tr>
<tr class="separator:a2eca1ca5aa6e819c88a65214289290d4 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc5a457c395fd7843ab36de74821fdd inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual std::atomic_int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a1fc5a457c395fd7843ab36de74821fdd">signal</a> ()=0</td></tr>
<tr class="memdesc:a1fc5a457c395fd7843ab36de74821fdd inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the underlying synchronization variable.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a1fc5a457c395fd7843ab36de74821fdd">More...</a><br /></td></tr>
<tr class="separator:a1fc5a457c395fd7843ab36de74821fdd inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a2eac3a5f775a2f7306c3d4a10d631 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a89a2eac3a5f775a2f7306c3d4a10d631">sleep</a> (const std::chrono::milliseconds &amp;timeMs)=0</td></tr>
<tr class="memdesc:a89a2eac3a5f775a2f7306c3d4a10d631 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps the coroutine associated with this context for <em>at least</em> 'timeMs' milliseconds or 'timeUs' microseconds depending on the overload chosen.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a89a2eac3a5f775a2f7306c3d4a10d631">More...</a><br /></td></tr>
<tr class="separator:a89a2eac3a5f775a2f7306c3d4a10d631 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20289c9f85157b6d76b46aefe401436 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#ad20289c9f85157b6d76b46aefe401436">sleep</a> (const std::chrono::microseconds &amp;timeUs)=0</td></tr>
<tr class="separator:ad20289c9f85157b6d76b46aefe401436 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RET&gt;<br />
interface Bloomberg::quantum::ICoroContext&lt; RET &gt;</h3>

<p>Exposes methods to manipulate the coroutine context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>The type of value returned via the promise associated with this context. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9c7bff480885fea5124d7cd781b383a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7bff480885fea5124d7cd781b383a1">&#9670;&nbsp;</a></span>ContextTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::<a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a9c7bff480885fea5124d7cd781b383a1">ContextTag</a> =  <a class="el" href="../../dd/d45/structBloomberg_1_1quantum_1_1CoroContextTag.html">CoroContextTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc1bf405803ddb27caea4277c0726890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1bf405803ddb27caea4277c0726890">&#9670;&nbsp;</a></span>Impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::<a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afc1bf405803ddb27caea4277c0726890">Impl</a> =  <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;RET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afda4bb817480a24960e407f6e977ed28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda4bb817480a24960e407f6e977ed28">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;RET&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7f2c171bda51b08ef7bf56f0d4aa5a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2c171bda51b08ef7bf56f0d4aa5a90">&#9670;&nbsp;</a></span>closeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::closeBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a promise buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Once closed no more Pushes can be made into the buffer. The corresponding future can still Pull values until the buffer is empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a60c1b4501689af034dfcb9c284b8286e">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ab2530e5e0231aaba5a2f06315f713300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2530e5e0231aaba5a2f06315f713300">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the last method in a continuation chain. </p>
<p>This method effectively closes the continuation chain and posts the entire chain to be executed, respecting the 'queueId' and priority specified at the beginning of the chain (see <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c" title="Posts a coroutine to run asynchronously.">postFirst()</a>). </p><dl class="section return"><dt>Returns</dt><dd>Pointer to this context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not take any functions as parameter as it is strictly used for scheduling purposes. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="adb6fe33799ff3e9175ac7b5a9d3fcbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6fe33799ff3e9175ac7b5a9d3fcbf4">&#9670;&nbsp;</a></span>finally() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad6ad88afbd04d2ff1d325ec3f785af98">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a315aa51f354c959bca0eaee24b90a26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315aa51f354c959bca0eaee24b90a26e">&#9670;&nbsp;</a></span>finally() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must immediately precede the <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a> method. This method will run regardless if any preceding coroutines have an error or not. It can be used for cleanup purposes, closing handles, terminating services, etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. After this coroutine, the <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a> method must be called. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad6ad88afbd04d2ff1d325ec3f785af98">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a67347c09d361d71b2e2b2b3b31f60202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67347c09d361d71b2e2b2b3b31f60202">&#9670;&nbsp;</a></span>forEach() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::vector&lt;OTHER_RET&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a72fde2c2c762191ad18a47da842bafbd">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a96495b0c3e9cfc2c1ad5ece71d72365c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a2f0df54e37ad9f6d8719ca56b5545e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0df54e37ad9f6d8719ca56b5545e4a">&#9670;&nbsp;</a></span>forEach() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::vector&lt;OTHER_RET&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a92e31d0c16163a70fa6835d0d894488b">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac3751b4edd7f4463e96d8a3b123c1d8c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a1132ca05b44a667a1e3b1633e02a1b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1132ca05b44a667a1e3b1633e02a1b23">&#9670;&nbsp;</a></span>forEach() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::vector&lt;OTHER_RET&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first element in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last element in the range (exclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a72fde2c2c762191ad18a47da842bafbd">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a96495b0c3e9cfc2c1ad5ece71d72365c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a06478eb5360e23d192533370f18154bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06478eb5360e23d192533370f18154bd">&#9670;&nbsp;</a></span>forEach() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::vector&lt;OTHER_RET&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] num The number of elements to iterate over. @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a92e31d0c16163a70fa6835d0d894488b">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac3751b4edd7f4463e96d8a3b123c1d8c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a73ec77ae4684f6ff01369199f15bf10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ec77ae4684f6ff01369199f15bf10f">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a77a8b62a0cc3c43ebb522b36c9f4feae">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a733bf9fc02a6fdc40034a7e9d10de66e">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a72e972a1d6e6f2d891f0300c32e13ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e972a1d6e6f2d891f0300c32e13ff3">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a11662c98402c70d00fe38c443537ba55">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5c18cd1e2335cc5ac0dd5efea999c20b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ab7f82d2d74ac1840dbe1332898a86796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f82d2d74ac1840dbe1332898a86796">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a77a8b62a0cc3c43ebb522b36c9f4feae">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a733bf9fc02a6fdc40034a7e9d10de66e">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a40a9f2692cfbbb3b3cfbf38d6ec6f75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9f2692cfbbb3b3cfbf38d6ec6f75e">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a11662c98402c70d00fe38c443537ba55">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5c18cd1e2335cc5ac0dd5efea999c20b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a330754e60be65d5ee5f73793c7f86f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330754e60be65d5ee5f73793c7f86f69">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value associated with this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future becomes invalidated (i.e. cannot be read again). </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad30a62675d2c29f3f62780cadbed8d0a">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a87a132655875ac6f07d5242e24d80a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a132655875ac6f07d5242e24d80a8d">&#9670;&nbsp;</a></span>getAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The future value of the 'num-th' coroutine context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future is invalidated (i.e. cannot be read again). </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad2e8e50aaf33e2f10b8343ff6f8bd7cb">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a9c60ca5034b9d1b19dd7279f3476bbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c60ca5034b9d1b19dd7279f3476bbec">&#9670;&nbsp;</a></span>getCoroQueueIdRangeForAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; int, int &gt; &amp; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getCoroQueueIdRangeForAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> by the <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html" title="Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main e...">Dispatcher</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>queueIdRange The range of queueIds that <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> covers </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a70e2d72600c412fdeca447b9b111991c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a0fadac955b2b32d87d1b8e505dce39c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fadac955b2b32d87d1b8e505dce39c3">&#9670;&nbsp;</a></span>getNumCoroutineThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getNumCoroutineThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of underlying coroutine threads as specified in the dispatcher constructor. If -1 was passed than this number essentially indicates the number of cores. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning coroutines to a specific queue. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a66b2fe051e1b72e6a045cb0a3e57b9d2">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a1efdbf7df3818aec9bc8fd98a5bfc640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efdbf7df3818aec9bc8fd98a5bfc640">&#9670;&nbsp;</a></span>getNumIoThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getNumIoThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of underlying IO threads as specified in the dispatcher constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning IO tasks to a specific queue. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5855eee0ab54a2d606cdc96196816a74">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a141e79103170cb9cb0fb0197d8df61e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141e79103170cb9cb0fb0197d8df61e5">&#9670;&nbsp;</a></span>getPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getPrev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value associated with the previous coroutine context in the continuation chain. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value of the previous context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Contrary to <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69" title="Get the future value associated with this context.">get()</a> or <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a43cf7ed9f70bc0123547b6baa6ec7c49" title="Get a reference the future value associated with this context.">getRef()</a> this function never blocks since the previous coroutine is guaranteed to have completed. Thus the future, if any, is already set. Once this function returns, the future becomes invalidated. </dd></dl>

</div>
</div>
<a id="a7aeb2b66b620b208cde57129a9293ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeb2b66b620b208cde57129a9293ec3">&#9670;&nbsp;</a></span>getPrevRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getPrevRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to future value associated with the previous coroutine context in the continuation chain. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value of the previous context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the previous future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not block. Contrary to <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a141e79103170cb9cb0fb0197d8df61e5" title="Get the future value associated with the previous coroutine context in the continuation chain.">getPrev()</a> this function will not invalidate the future, thus it can be read again. </dd></dl>

</div>
</div>
<a id="a43cf7ed9f70bc0123547b6baa6ec7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf7ed9f70bc0123547b6baa6ec7c49">&#9670;&nbsp;</a></span>getRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference the future value associated with this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69" title="Get the future value associated with this context.">get()</a>, this function does not invalidate the future and as such may be read again. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ae31a1b88bfd1fb6afcd8ccb8b2921d97">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3c64853ee6c868f4e83668f17d4efd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c64853ee6c868f4e83668f17d4efd95">&#9670;&nbsp;</a></span>getRefAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::getRefAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value of the 'num-th' coroutine context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a87a132655875ac6f07d5242e24d80a8d" title="Get the future value from the &#39;num-th&#39; continuation context.">getAt()</a> this function will not invalidate the future and as such it can be read again. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a8aadfc75a4cd426986fb008af86ed6f9">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a946b3473429275faee4dc0a77ea7f9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946b3473429275faee4dc0a77ea7f9d6">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a7121593247706c863a13f75de3a87e2c">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a18aa2559b6617f7f20eb19d7ede69f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aa2559b6617f7f20eb19d7ede69f36">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a89aa2e2af2ef2105e2933d13370c9705">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac0adbfbb086a16877fe6d9c5854514">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a876d52748c66869620cdb9753783a86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876d52748c66869620cdb9753783a86e">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of map-reduce functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KEY</td><td>The KEY type used for mapping and reducing. </td></tr>
    <tr><td class="paramname">MAPPED_TYPE</td><td>The output type after a map operation. </td></tr>
    <tr><td class="paramname">REDUCED_TYPE</td><td>The output type after a reduce operation. </td></tr>
    <tr><td class="paramname">MAPPER_FUNC</td><td>The mapper function having the signature 'std::vector&lt;std::pair&lt;KEY,MAPPED_TYPE&gt;&gt;(*INPUT_IT)' </td></tr>
    <tr><td class="paramname">REDUCER_FUNC</td><td>The reducer function having the signature 'std::pair&lt;KEY,REDUCED_TYPE&gt;(std::pair&lt;KEY, std::vector&lt;MAPPED_TYPE&gt;&gt;&amp;&amp;)' </td></tr>
    <tr><td class="paramname">INPUT_IT</td><td>The iterator type. @oaram[in] first The start iterator to a list of items to be processed in the range [first,last). @oaram[in] last The end iterator to a list of items (not inclusive). @oaram[in] mapper The mapper function. @oaram[in] reducer The reducer function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to a reduced map of values. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a7121593247706c863a13f75de3a87e2c">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="af26ac90a03f5a15b231732597f0c311e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26ac90a03f5a15b231732597f0c311e">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a89aa2e2af2ef2105e2933d13370c9705">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac0adbfbb086a16877fe6d9c5854514">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="aebd9a82576780fcb50db98f1414e0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd9a82576780fcb50db98f1414e0a73">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#afa84de805a985c05658303b8ae313b50">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3868683cd9afc1b37d7c5bdb213bdda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3868683cd9afc1b37d7c5bdb213bdda7">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2b14b52e110fcc608b64ba6323c32859">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ada436f5169fa19522fb20591e865e95c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="afa8065d1270e5205c09720d1faf5307a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8065d1270e5205c09720d1faf5307a">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO. </p>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#afa84de805a985c05658303b8ae313b50">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3d6b21c20bc63231bc2ad1e847079183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6b21c20bc63231bc2ad1e847079183">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afa8065d1270e5205c09720d1faf5307a" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2b14b52e110fcc608b64ba6323c32859">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ada436f5169fa19522fb20591e865e95c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a1c1cf14d5eb019962a98578eacb5b8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1cf14d5eb019962a98578eacb5b8ed">&#9670;&nbsp;</a></span>onError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::onError </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a311a7045f6c47e5aba887d109bb08a20">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="abc0fd314e1dbc93055a0107c390b8af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0fd314e1dbc93055a0107c390b8af9">&#9670;&nbsp;</a></span>onError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::onError </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must follow <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a> method. This method will conditionally run if-and-only-if any previous coroutines in the continuation chain return an error or throw. When a coroutine which is part of a continuation chain has an error, all subsequent <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a> methods are skipped and if <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> is provided it will be called. If there are no errors, this method is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function is non-blocking. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a311a7045f6c47e5aba887d109bb08a20">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a7e16a0f4dda08ea619bbd3997f31a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e16a0f4dda08ea619bbd3997f31a51e">&#9670;&nbsp;</a></span>post() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<dl class="section attention"><dt>Attention</dt><dd>Continuation methods are typically chained in the following manner and must follow the relative placement below. <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c" title="Posts a coroutine to run asynchronously.">postFirst()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a> are the only mandatory methods. <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> can be called at most once, whereas <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a> may be called zero or more times.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afda4bb817480a24960e407f6e977ed28">ICoroContext&lt;RET&gt;::Ptr</a> ctx = <a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">ICoroContext::postFirst</a>()-&gt;then()-&gt;...-&gt;then()-&gt;onError()-&gt;finally()-&gt;end();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e" title="Post a coroutine to run asynchronously.">post()</a> methods are standalone and do not allow continuations.</dd></dl>
<p>This method will post the coroutine on any thread available. Typically it will pick one which has the smallest number of concurrent coroutines executing at the time of the post. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a565e441cfddcbb984ce5fa22f3dbcff8">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a7012d092efbd20c729b3c150facb97bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7012d092efbd20c729b3c150facb97bb">&#9670;&nbsp;</a></span>post() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on the specified queue (thread) with high or low priority. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a730c6f56d768eef190f1b1da2555ef00">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a25741cad8e14d880665fcbe626a1cc5f">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a7d0926e2c70ccc27b4234d9c966a4c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0926e2c70ccc27b4234d9c966a4c48">&#9670;&nbsp;</a></span>post() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a565e441cfddcbb984ce5fa22f3dbcff8">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a70d652e9a349be10d4f034bfd85701a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d652e9a349be10d4f034bfd85701a6">&#9670;&nbsp;</a></span>post() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a730c6f56d768eef190f1b1da2555ef00">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a25741cad8e14d880665fcbe626a1cc5f">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="aafa32c808db9c73262f5336b03f2055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa32c808db9c73262f5336b03f2055a">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts an IO method to run asynchronously on the IO thread pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this function. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine future object which may be used to retrieve the result of the IO operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not block. The passed function will not be wrapped in a coroutine. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a18431eacd784c497f727852c508597b5">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a03a77b36de1443b63583e4217e33fb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a77b36de1443b63583e4217e33fb62">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts an IO function to run asynchronously on the IO thread pool. </p>
<p>This method will post the function on the specified queue (thread) with high or low priority. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this function. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this function should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#aafa32c808db9c73262f5336b03f2055a" title="Posts an IO method to run asynchronously on the IO thread pool.">postAsyncIo()</a> above. Valid range is [0, numIoThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> is disallowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the function will be scheduled to run immediately after the currently executing function on 'queueId' has completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine future object which may be used to retrieve the result of the IO operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not block. The passed function will not be wrapped in a coroutine. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a0559064ed7daf706dde029b2c23272d3">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a4563ab7eb43249f2ad8677935b0b002c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4563ab7eb43249f2ad8677935b0b002c">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#add67969159e847e044800e7f48777534">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3ca0bf6a7feb401d3f3c82518cf54b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca0bf6a7feb401d3f3c82518cf54b06">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a3b509b33a26d72ff2e8e9884dfba84e5">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a234052af61bc6a306e12f5cb4baddd46">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a543d671426210cedd613440c4fde74d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543d671426210cedd613440c4fde74d5">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#add67969159e847e044800e7f48777534">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ac0b1a065188c41efac3d1deed1357b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b1a065188c41efac3d1deed1357b89">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a3b509b33a26d72ff2e8e9884dfba84e5">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a234052af61bc6a306e12f5cb4baddd46">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a218dc6b764b01a685e37840a796fe0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218dc6b764b01a685e37840a796fe0eb">&#9670;&nbsp;</a></span>pull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::pull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isBufferClosed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull a single value from the future buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
    <tr><td class="paramname">V</td><td>The type of value contained in <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isBufferClosed</td><td>Indicates if this buffer is closed and no more Pull operations are allowed on it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next value pulled out from the front of the buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Method available for buffered futures only. Blocks until one value is retrieved from the buffer. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ae946ad090fec1eb3ab2b37b7d958225d">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a18a76d5a8b8d68567bf706f468d69ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a76d5a8b8d68567bf706f468d69ea2">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::push </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a single value into the promise buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
    <tr><td class="paramname">V</td><td>The type of value contained in <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push at the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Method available for buffered futures only. Never blocks. Once the buffer is closed, no more Push operations are allowed. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6cc68322709515d1586cf453276f2100">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a984eea6da10575adfba1a38d3b09ebd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984eea6da10575adfba1a38d3b09ebd7">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::set </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the promised value associated with this context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of the promised value. This should be implicitly deduced by the compiler and should always == RET. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A reference to the value (l-value or r-value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Never blocks. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aaf24cac3dcdf0bf21b7301e606fa4d1a">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a8f79744d5e5f3d9460024877a0cd07a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f79744d5e5f3d9460024877a0cd07a5">&#9670;&nbsp;</a></span>then() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a8cf6f8fd7d169988428556468b333fe1">CoroContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::then </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a1848dc5d7547ba112a44721951603669">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a122f96fbe956dcc2205564b1e953d8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122f96fbe956dcc2205564b1e953d8fc">&#9670;&nbsp;</a></span>then() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET  = int, class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext</a>&lt; RET &gt;::then </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is optional for the continuation chain and may be called 0 or more times. If called, it must follow <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a> method. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and runs when all previous chained coroutines have completed. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implemented in <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a1848dc5d7547ba112a44721951603669">Bloomberg::quantum::Context&lt; RET &gt;</a>, and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c">Bloomberg::quantum::Context&lt; RET &gt;</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/db9/namespaceBloomberg.html">Bloomberg</a></li><li class="navelem"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
