<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantumLibrary: Bloomberg::quantum::Sequencer&lt; SequenceKey, Hash, KeyEqual, Allocator &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantumLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d3/de7/classBloomberg_1_1quantum_1_1Sequencer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bloomberg::quantum::Sequencer&lt; SequenceKey, Hash, KeyEqual, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a key-based task sequencing with quantum.  
 <a href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d4/da2/quantum__sequencer_8h_source.html">quantum_sequencer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8002b0e144b13e677f86c8247c398679"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a> = <a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html">SequencerConfiguration</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;</td></tr>
<tr class="memdesc:a8002b0e144b13e677f86c8247c398679"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html">Configuration</a> class for <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html" title="Implementation of a key-based task sequencing with quantum.">Sequencer</a>.  <a href="#a8002b0e144b13e677f86c8247c398679">More...</a><br /></td></tr>
<tr class="separator:a8002b0e144b13e677f86c8247c398679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdd8a154a4c2b7c79a825401d58cb542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#afdd8a154a4c2b7c79a825401d58cb542">Sequencer</a> (<a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html">Dispatcher</a> &amp;dispatcher, const <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a> &amp;configuration=<a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a>())</td></tr>
<tr class="memdesc:afdd8a154a4c2b7c79a825401d58cb542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#afdd8a154a4c2b7c79a825401d58cb542">More...</a><br /></td></tr>
<tr class="separator:afdd8a154a4c2b7c79a825401d58cb542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937a0e6d89e61676c3f41fbac6113190"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a937a0e6d89e61676c3f41fbac6113190"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a937a0e6d89e61676c3f41fbac6113190">post</a> (const SequenceKey &amp;sequenceKey, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a937a0e6d89e61676c3f41fbac6113190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a937a0e6d89e61676c3f41fbac6113190">More...</a><br /></td></tr>
<tr class="separator:a937a0e6d89e61676c3f41fbac6113190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f91fe60a6ecdf703e905d9e80ab050"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a30f91fe60a6ecdf703e905d9e80ab050"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a30f91fe60a6ecdf703e905d9e80ab050">post</a> (void *opaque, int queueId, bool isHighPriority, const SequenceKey &amp;sequenceKey, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a30f91fe60a6ecdf703e905d9e80ab050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously on a specific queue (thread).  <a href="#a30f91fe60a6ecdf703e905d9e80ab050">More...</a><br /></td></tr>
<tr class="separator:a30f91fe60a6ecdf703e905d9e80ab050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0500f8162dde207bd80eeb107c681b87"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a0500f8162dde207bd80eeb107c681b87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a0500f8162dde207bd80eeb107c681b87">post</a> (const std::vector&lt; SequenceKey &gt; &amp;sequenceKeys, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0500f8162dde207bd80eeb107c681b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a0500f8162dde207bd80eeb107c681b87">More...</a><br /></td></tr>
<tr class="separator:a0500f8162dde207bd80eeb107c681b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d528e25a8be01030897690cb6e8bf"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:af29d528e25a8be01030897690cb6e8bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#af29d528e25a8be01030897690cb6e8bf">post</a> (void *opaque, int queueId, bool isHighPriority, const std::vector&lt; SequenceKey &gt; &amp;sequenceKeys, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:af29d528e25a8be01030897690cb6e8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously on a specific queue (thread).  <a href="#af29d528e25a8be01030897690cb6e8bf">More...</a><br /></td></tr>
<tr class="separator:af29d528e25a8be01030897690cb6e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d8c07adb82569e164e9855bc276d88"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:ac9d8c07adb82569e164e9855bc276d88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#ac9d8c07adb82569e164e9855bc276d88">postAll</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac9d8c07adb82569e164e9855bc276d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#ac9d8c07adb82569e164e9855bc276d88">More...</a><br /></td></tr>
<tr class="separator:ac9d8c07adb82569e164e9855bc276d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c1ebefb4f2750e0c8255768251943"><td class="memTemplParams" colspan="2">template&lt;class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:ab66c1ebefb4f2750e0c8255768251943"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#ab66c1ebefb4f2750e0c8255768251943">postAll</a> (void *opaque, int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab66c1ebefb4f2750e0c8255768251943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously on a specific queue (thread).  <a href="#ab66c1ebefb4f2750e0c8255768251943">More...</a><br /></td></tr>
<tr class="separator:ab66c1ebefb4f2750e0c8255768251943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd829f905b972e2de960266916fa0a45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#abd829f905b972e2de960266916fa0a45">trimSequenceKeys</a> ()</td></tr>
<tr class="memdesc:abd829f905b972e2de960266916fa0a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the sequence keys not used by the sequencer anymore.  <a href="#abd829f905b972e2de960266916fa0a45">More...</a><br /></td></tr>
<tr class="separator:abd829f905b972e2de960266916fa0a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2876ae96cd9c1d763913547eea8c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a89c2876ae96cd9c1d763913547eea8c3">getSequenceKeyCount</a> ()</td></tr>
<tr class="memdesc:a89c2876ae96cd9c1d763913547eea8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of tracked sequence keys.  <a href="#a89c2876ae96cd9c1d763913547eea8c3">More...</a><br /></td></tr>
<tr class="separator:a89c2876ae96cd9c1d763913547eea8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2586ba82764636ae3fee35d87d9fc5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a2586ba82764636ae3fee35d87d9fc5ec">getStatistics</a> (const SequenceKey &amp;sequenceKey)</td></tr>
<tr class="memdesc:a2586ba82764636ae3fee35d87d9fc5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sequencer statistics for a specific sequence key.  <a href="#a2586ba82764636ae3fee35d87d9fc5ec">More...</a><br /></td></tr>
<tr class="separator:a2586ba82764636ae3fee35d87d9fc5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c32319c7f039aa8dc0239ea4942c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#ac3c32319c7f039aa8dc0239ea4942c0c">getStatistics</a> ()</td></tr>
<tr class="memdesc:ac3c32319c7f039aa8dc0239ea4942c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sequencer statistics for the 'universal key', a.k.a. posted via <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#ac9d8c07adb82569e164e9855bc276d88" title="Post a coroutine to run asynchronously.">postAll()</a> method.  <a href="#ac3c32319c7f039aa8dc0239ea4942c0c">More...</a><br /></td></tr>
<tr class="separator:ac3c32319c7f039aa8dc0239ea4942c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34071c93599ed20646264a009b4aa39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#aa34071c93599ed20646264a009b4aa39">getTaskStatistics</a> ()</td></tr>
<tr class="memdesc:aa34071c93599ed20646264a009b4aa39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sequencer statistics for all jobs.  <a href="#aa34071c93599ed20646264a009b4aa39">More...</a><br /></td></tr>
<tr class="separator:aa34071c93599ed20646264a009b4aa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class SequenceKey, class Hash = std::hash&lt;SequenceKey&gt;, class KeyEqual = std::equal_to&lt;SequenceKey&gt;, class Allocator = std::allocator&lt;std::pair&lt;const SequenceKey, SequenceKeyData&gt;&gt;&gt;<br />
class Bloomberg::quantum::Sequencer&lt; SequenceKey, Hash, KeyEqual, Allocator &gt;</h3>

<p>Implementation of a key-based task sequencing with quantum. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SequenceKey</td><td>Type of the key based that sequenced tasks are associated with </td></tr>
    <tr><td class="paramname">Hash</td><td>Hash-function used for storing instances of SequenceKey in hash maps </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>The equal-function used for storing instances of SequenceKey in hash maps </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a></td><td>The allocator used for storing instances of SequenceKey in hash maps </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8002b0e144b13e677f86c8247c398679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8002b0e144b13e677f86c8247c398679">&#9670;&nbsp;</a></span>Configuration</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash  = std::hash&lt;SequenceKey&gt;, class KeyEqual  = std::equal_to&lt;SequenceKey&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const SequenceKey, SequenceKeyData&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::<a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a> =  <a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html">SequencerConfiguration</a>&lt;SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html">Configuration</a> class for <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html" title="Implementation of a key-based task sequencing with quantum.">Sequencer</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdd8a154a4c2b7c79a825401d58cb542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd8a154a4c2b7c79a825401d58cb542">&#9670;&nbsp;</a></span>Sequencer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash  = std::hash&lt;SequenceKey&gt;, class KeyEqual  = std::equal_to&lt;SequenceKey&gt;, class Allocator  = std::allocator&lt;std::pair&lt;const SequenceKey, SequenceKeyData&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::<a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Sequencer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html">Dispatcher</a> &amp;&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em> = <code><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a8002b0e144b13e677f86c8247c398679">Configuration</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dispatcher</td><td><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html" title="Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main e...">Dispatcher</a> for all task dispatching </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configuration</td><td>the configuration object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89c2876ae96cd9c1d763913547eea8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c2876ae96cd9c1d763913547eea8c3">&#9670;&nbsp;</a></span>getSequenceKeyCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::getSequenceKeyCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of tracked sequence keys. </p>
<dl class="section return"><dt>Returns</dt><dd>sequence key count </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the statistics computation job posted to the dispatcher is finished. </dd></dl>

</div>
</div>
<a id="a2586ba82764636ae3fee35d87d9fc5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2586ba82764636ae3fee35d87d9fc5ec">&#9670;&nbsp;</a></span>getStatistics() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a> <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::getStatistics </td>
          <td>(</td>
          <td class="paramtype">const SequenceKey &amp;&#160;</td>
          <td class="paramname"><em>sequenceKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sequencer statistics for a specific sequence key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequenceKey</td><td>the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the statistics objects for the specified key </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the statistics computation job posted to the dispatcher is finished. </dd></dl>

</div>
</div>
<a id="ac3c32319c7f039aa8dc0239ea4942c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c32319c7f039aa8dc0239ea4942c0c">&#9670;&nbsp;</a></span>getStatistics() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a> <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::getStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sequencer statistics for the 'universal key', a.k.a. posted via <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#ac9d8c07adb82569e164e9855bc276d88" title="Post a coroutine to run asynchronously.">postAll()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>the statistics objects </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the statistics computation job posted to the dispatcher is finished. </dd></dl>

</div>
</div>
<a id="aa34071c93599ed20646264a009b4aa39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34071c93599ed20646264a009b4aa39">&#9670;&nbsp;</a></span>getTaskStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/df6/classBloomberg_1_1quantum_1_1SequenceKeyStatistics.html">SequenceKeyStatistics</a> <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::getTaskStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the sequencer statistics for all jobs. </p>
<dl class="section return"><dt>Returns</dt><dd>the statistics objects </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The difference with the previous two statistics methods is that it aggregates stats on a per-task basis, not on per-key basis. </dd></dl>

</div>
</div>
<a id="a937a0e6d89e61676c3f41fbac6113190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937a0e6d89e61676c3f41fbac6113190">&#9670;&nbsp;</a></span>post() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::post </td>
          <td>(</td>
          <td class="paramtype">const SequenceKey &amp;&#160;</td>
          <td class="paramname"><em>sequenceKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on any thread available and will run when the previous coroutine associated with the same 'sequenceKey' completes. If there are none, it will run immediately. (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sequenceKey</td><td>SequenceKey object that the posted task is associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, it is suggested that the configured Any-coroutine-queue-range (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id (</dd>
<dd>
<a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). </dd></dl>

</div>
</div>
<a id="a30f91fe60a6ecdf703e905d9e80ab050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f91fe60a6ecdf703e905d9e80ab050">&#9670;&nbsp;</a></span>post() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::post </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SequenceKey &amp;&#160;</td>
          <td class="paramname"><em>sequenceKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously on a specific queue (thread). </p>
<p>This method will post the coroutine on any thread available and will run when the previous coroutine associated with the same 'sequenceKey' completes. If there are none, it will run immediately. (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a937a0e6d89e61676c3f41fbac6113190" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the sequencer coroutine will be scheduled right after the currently executing coroutine on 'queueId'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>pointer to opaque data that is passed to the exception handler (if provided) if an unhandled exception is thrown in func </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sequenceKey</td><td>SequenceKey object that the posted task is associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, queueId is suggested to be different from the control queue id (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). Hence, if <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is intended to be used as queueId here, then it is suggested that the configured Any-coroutine-queue-range (</dd>
<dd>
<a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id. </dd></dl>

</div>
</div>
<a id="a0500f8162dde207bd80eeb107c681b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0500f8162dde207bd80eeb107c681b87">&#9670;&nbsp;</a></span>post() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::post </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; SequenceKey &gt; &amp;&#160;</td>
          <td class="paramname"><em>sequenceKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on any thread available and will run when the previous coroutine(s) associated with all the 'sequenceKeys' complete. If there are none, then it will run immediately. (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sequenceKeys</td><td>A collection of sequenceKey objects that the posted task is associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, it is suggested that the configured Any-coroutine-queue-range (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id (</dd>
<dd>
<a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). </dd></dl>

</div>
</div>
<a id="af29d528e25a8be01030897690cb6e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29d528e25a8be01030897690cb6e8bf">&#9670;&nbsp;</a></span>post() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::post </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SequenceKey &gt; &amp;&#160;</td>
          <td class="paramname"><em>sequenceKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously on a specific queue (thread). </p>
<p>This method will post the coroutine on any thread available and will run when the previous coroutine(s) associated with all the 'sequenceKeys' complete. If there are none, then it will run immediately. (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a937a0e6d89e61676c3f41fbac6113190" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the sequencer coroutine will be scheduled right after the currently executing coroutine on 'queueId'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>pointer to opaque data that is passed to the exception handler (if provided) if an unhandled exception is thrown in func </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sequenceKeys</td><td>A collection of sequenceKey objects that the posted task is associated with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, queueId is suggested to be different from the control queue id (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). Hence, if <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is intended to be used as queueId here, then it is suggested that the configured Any-coroutine-queue-range (</dd>
<dd>
<a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id. </dd></dl>

</div>
</div>
<a id="ac9d8c07adb82569e164e9855bc276d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d8c07adb82569e164e9855bc276d88">&#9670;&nbsp;</a></span>postAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::postAll </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on any thread available. The posted task is assumed to be associated with the entire universe of sequenceKeys already running or pending, which means that it will wait until all tasks complete. This task can be considered as having a 'universal' key. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, it is suggested that the configured Any-coroutine-queue-range (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id (</dd>
<dd>
<a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). </dd></dl>

</div>
</div>
<a id="ab66c1ebefb4f2750e0c8255768251943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c1ebefb4f2750e0c8255768251943">&#9670;&nbsp;</a></span>postAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
<div class="memtemplate">
template&lt;class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::postAll </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously on a specific queue (thread). </p>
<p>This method will post the coroutine on any thread available. The posted task is assumed to be associated with the entire universe of sequenceKeys already running or pending, which means that it will wait until all tasks complete. This task can be considered as having a 'universal' key. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a> for more details). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html#a937a0e6d89e61676c3f41fbac6113190" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the sequencer coroutine will be scheduled right after the currently executing coroutine on 'queueId'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>pointer to opaque data that is passed to the exception handler (if provided) if an unhandled exception is thrown in func </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>For lowering the latencies of processing tasks posted here, queueId is suggested to be different from the control queue id (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/df2/classBloomberg_1_1quantum_1_1SequencerConfiguration.html#ab3f471e82f74c2038ea5837e0503adf7" title="Sets the id of the control queue.">SequencerConfiguration::setControlQueueId</a>). Hence, if <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is intended to be used as queueId here, then it is suggested that the configured Any-coroutine-queue-range (</dd>
<dd>
<a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html#a5c7b190a980d1eddaf6e25f9b3bdb528" title="Sets the range of coroutine queueIds covered by IQueue::QueueId::Any when using Dispatcher::post.">Configuration::setCoroQueueIdRangeForAny</a>) does not contain the control queue id. </dd></dl>

</div>
</div>
<a id="abd829f905b972e2de960266916fa0a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd829f905b972e2de960266916fa0a45">&#9670;&nbsp;</a></span>trimSequenceKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SequenceKey , class Hash , class KeyEqual , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Bloomberg::quantum::Sequencer</a>&lt; SequenceKey, Hash, KeyEqual, <a class="el" href="../../d7/df5/structBloomberg_1_1quantum_1_1Allocator.html">Allocator</a> &gt;::trimSequenceKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the sequence keys not used by the sequencer anymore. </p>
<p>It's recommended to call this function periodically to clean up state sequence keys. </p><dl class="section remark"><dt>Remarks</dt><dd>This call clears all the statistics for trimmed keys. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of sequenceKeys after the trimming. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until the trimming job posted to the dispatcher is finished </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/db9/namespaceBloomberg.html">Bloomberg</a></li><li class="navelem"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="../../d7/d45/classBloomberg_1_1quantum_1_1Sequencer.html">Sequencer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
