<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantumLibrary: Bloomberg::quantum::Context&lt; RET &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantumLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d8/df7/classBloomberg_1_1quantum_1_1Context.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/dbc/classBloomberg_1_1quantum_1_1Context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bloomberg::quantum::Context&lt; RET &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Concrete class representing a coroutine or a thread context.  
 <a href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d5/db7/quantum__icoro__context_8h_source.html">quantum_icoro_context.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Bloomberg::quantum::Context&lt; RET &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d8/df7/classBloomberg_1_1quantum_1_1Context.png" usemap="#Bloomberg::quantum::Context_3C_20RET_20_3E_map" alt=""/>
  <map id="Bloomberg::quantum::Context_3C_20RET_20_3E_map" name="Bloomberg::quantum::Context_3C_20RET_20_3E_map">
<area href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html" title="Exposes methods to manipulate the thread context." alt="Bloomberg::quantum::IThreadContext&lt; RET &gt;" shape="rect" coords="0,112,289,136"/>
<area href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html" title="Exposes methods to manipulate the coroutine context." alt="Bloomberg::quantum::ICoroContext&lt; RET &gt;" shape="rect" coords="448,112,737,136"/>
<area href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html" title="Interface to a task accessor. For internal use only." alt="Bloomberg::quantum::ITaskAccessor" shape="rect" coords="747,112,1036,136"/>
<area href="../../da/d4d/structBloomberg_1_1quantum_1_1IThreadContextBase.html" title="Exposes methods to manipulate the thread context, especially future wait methods." alt="Bloomberg::quantum::IThreadContextBase" shape="rect" coords="0,56,289,80"/>
<area href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html" title="Exposes methods to manipulate the coroutine context, especially future wait methods." alt="Bloomberg::quantum::ICoroContextBase" shape="rect" coords="448,56,737,80"/>
<area href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html" title="Represents an object which can be terminated. This interface allows certain objects to be explicitly ..." alt="Bloomberg::quantum::ITerminate" shape="rect" coords="747,56,1036,80"/>
<area href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html" title="This interface exposes shared functionality between IThreadContext and ICoroContext." alt="Bloomberg::quantum::IContextBase" shape="rect" coords="0,0,289,24"/>
<area href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html" title="This interface exposes shared functionality between IThreadContext and ICoroContext." alt="Bloomberg::quantum::IContextBase" shape="rect" coords="299,0,588,24"/>
<area href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html" title="Provides an interface to facilitate &#39;implicit&#39; coroutine yielding within other primitives such as mut..." alt="Bloomberg::quantum::ICoroSync" shape="rect" coords="598,0,887,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a93fbe0e7fa77b4b98f35ee2935dfaa83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a93fbe0e7fa77b4b98f35ee2935dfaa83">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt; &gt;</td></tr>
<tr class="separator:a93fbe0e7fa77b4b98f35ee2935dfaa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa527cfac3a074ace54db74a9758f45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a0aa527cfac3a074ace54db74a9758f45">ThreadCtx</a> = <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html">IThreadContext</a>&lt; RET &gt;</td></tr>
<tr class="separator:a0aa527cfac3a074ace54db74a9758f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879043028bc5aeb46aa484d34d464314"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a879043028bc5aeb46aa484d34d464314">CoroCtx</a> = <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; RET &gt;</td></tr>
<tr class="separator:a879043028bc5aeb46aa484d34d464314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1IThreadContext')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a></td></tr>
<tr class="memitem:ac70ef12cc80708a891d3ca1090adff2e inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#ac70ef12cc80708a891d3ca1090adff2e">ContextTag</a> = <a class="el" href="../../de/de9/structBloomberg_1_1quantum_1_1ThreadContextTag.html">ThreadContextTag</a></td></tr>
<tr class="separator:ac70ef12cc80708a891d3ca1090adff2e inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7724a925c43a5a9661e90f7f331651 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a0b7724a925c43a5a9661e90f7f331651">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html">IThreadContext</a>&lt; RET &gt; &gt;</td></tr>
<tr class="separator:a0b7724a925c43a5a9661e90f7f331651 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c1dd50a3abd82d5d881eeda65e32e5 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#ab3c1dd50a3abd82d5d881eeda65e32e5">Impl</a> = <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt;</td></tr>
<tr class="separator:ab3c1dd50a3abd82d5d881eeda65e32e5 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1IThreadContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1IThreadContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../da/d4d/structBloomberg_1_1quantum_1_1IThreadContextBase.html">Bloomberg::quantum::IThreadContextBase</a></td></tr>
<tr class="memitem:a95643a462eecd0836f9fd348703f77a2 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContextBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d4d/structBloomberg_1_1quantum_1_1IThreadContextBase.html#a95643a462eecd0836f9fd348703f77a2">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../da/d4d/structBloomberg_1_1quantum_1_1IThreadContextBase.html">IThreadContextBase</a> &gt;</td></tr>
<tr class="separator:a95643a462eecd0836f9fd348703f77a2 inherit pub_types_structBloomberg_1_1quantum_1_1IThreadContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1IContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">Bloomberg::quantum::IContextBase</a></td></tr>
<tr class="memitem:ac92e5d294479f777fd01f5621e4f8db9 inherit pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">IContextBase</a> &gt;</td></tr>
<tr class="separator:ac92e5d294479f777fd01f5621e4f8db9 inherit pub_types_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ICoroContext')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a></td></tr>
<tr class="memitem:a9c7bff480885fea5124d7cd781b383a1 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a9c7bff480885fea5124d7cd781b383a1">ContextTag</a> = <a class="el" href="../../dd/d45/structBloomberg_1_1quantum_1_1CoroContextTag.html">CoroContextTag</a></td></tr>
<tr class="separator:a9c7bff480885fea5124d7cd781b383a1 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4bb817480a24960e407f6e977ed28 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afda4bb817480a24960e407f6e977ed28">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt; RET &gt; &gt;</td></tr>
<tr class="separator:afda4bb817480a24960e407f6e977ed28 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1bf405803ddb27caea4277c0726890 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afc1bf405803ddb27caea4277c0726890">Impl</a> = <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt;</td></tr>
<tr class="separator:afc1bf405803ddb27caea4277c0726890 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html">Bloomberg::quantum::ICoroContextBase</a></td></tr>
<tr class="memitem:aa480ed235fb4eddf594fe5731c54ccab inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#aa480ed235fb4eddf594fe5731c54ccab">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html">ICoroContextBase</a> &gt;</td></tr>
<tr class="separator:aa480ed235fb4eddf594fe5731c54ccab inherit pub_types_structBloomberg_1_1quantum_1_1ICoroContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ICoroSync')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">Bloomberg::quantum::ICoroSync</a></td></tr>
<tr class="memitem:a109b2c4b7d70d53d48bb640a9d849b29 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">ICoroSync</a> &gt;</td></tr>
<tr class="separator:a109b2c4b7d70d53d48bb640a9d849b29 inherit pub_types_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structBloomberg_1_1quantum_1_1ITaskAccessor"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structBloomberg_1_1quantum_1_1ITaskAccessor')"><img src="../../closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html">Bloomberg::quantum::ITaskAccessor</a></td></tr>
<tr class="memitem:a77cb6ef586bd4e2ee6ae9d3efabf5be9 inherit pub_types_structBloomberg_1_1quantum_1_1ITaskAccessor"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html#a77cb6ef586bd4e2ee6ae9d3efabf5be9">Ptr</a> = std::shared_ptr&lt; <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html">ITaskAccessor</a> &gt;</td></tr>
<tr class="separator:a77cb6ef586bd4e2ee6ae9d3efabf5be9 inherit pub_types_structBloomberg_1_1quantum_1_1ITaskAccessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27f69b3023acdc46fc3145db80ea1b68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a27f69b3023acdc46fc3145db80ea1b68">~Context</a> ()</td></tr>
<tr class="separator:a27f69b3023acdc46fc3145db80ea1b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bac8f4101d8469756bb27b1c0b7f9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a8bac8f4101d8469756bb27b1c0b7f9dc">terminate</a> () final</td></tr>
<tr class="memdesc:a8bac8f4101d8469756bb27b1c0b7f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the object.  <a href="#a8bac8f4101d8469756bb27b1c0b7f9dc">More...</a><br /></td></tr>
<tr class="separator:a8bac8f4101d8469756bb27b1c0b7f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a828ab3f18b336f310191e04bae154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ae5a828ab3f18b336f310191e04bae154">setTask</a> (<a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#a6c5b8216547b11f3f0e0e6bc7d20956d">ITask::Ptr</a> task) final</td></tr>
<tr class="separator:ae5a828ab3f18b336f310191e04bae154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71819413eb6ab86661343d31e5ba9acb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#a6c5b8216547b11f3f0e0e6bc7d20956d">ITask::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a71819413eb6ab86661343d31e5ba9acb">getTask</a> () const final</td></tr>
<tr class="separator:a71819413eb6ab86661343d31e5ba9acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db6bb1798fc7c74534648e2091ad5be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a8db6bb1798fc7c74534648e2091ad5be">isBlocked</a> () const final</td></tr>
<tr class="separator:a8db6bb1798fc7c74534648e2091ad5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd8c1fdeb5ca8594a2af08dd74c7ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#addfd8c1fdeb5ca8594a2af08dd74c7ca">isSleeping</a> (bool updateTimer=false) final</td></tr>
<tr class="separator:addfd8c1fdeb5ca8594a2af08dd74c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef705383af39db02acc63c0dd8e4a321"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aef705383af39db02acc63c0dd8e4a321">valid</a> () const final</td></tr>
<tr class="memdesc:aef705383af39db02acc63c0dd8e4a321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the future object associated with this context has a valid shared state with the corresponding promise.  <a href="#aef705383af39db02acc63c0dd8e4a321">More...</a><br /></td></tr>
<tr class="separator:aef705383af39db02acc63c0dd8e4a321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23416d558addcca3ba223c3ff689672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ab23416d558addcca3ba223c3ff689672">validAt</a> (int num) const final</td></tr>
<tr class="memdesc:ab23416d558addcca3ba223c3ff689672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the future object associated with the 'num'-th continuation context is still valid.  <a href="#ab23416d558addcca3ba223c3ff689672">More...</a><br /></td></tr>
<tr class="separator:ab23416d558addcca3ba223c3ff689672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71ccef08af22fdde662e7df560dccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5a71ccef08af22fdde662e7df560dccb">setException</a> (std::exception_ptr ex) final</td></tr>
<tr class="memdesc:a5a71ccef08af22fdde662e7df560dccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an exception in the promise associated with the current <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html" title="Exposes methods to manipulate the thread context.">IThreadContext</a> or <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html" title="Exposes methods to manipulate the coroutine context.">ICoroContext</a>.  <a href="#a5a71ccef08af22fdde662e7df560dccb">More...</a><br /></td></tr>
<tr class="separator:a5a71ccef08af22fdde662e7df560dccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89818fc8478508cad80c6cdb833e2dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac89818fc8478508cad80c6cdb833e2dd">waitAt</a> (int num) const final</td></tr>
<tr class="memdesc:ac89818fc8478508cad80c6cdb833e2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready.  <a href="#ac89818fc8478508cad80c6cdb833e2dd">More...</a><br /></td></tr>
<tr class="separator:ac89818fc8478508cad80c6cdb833e2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a7039dd07811ced226e5adc29d6819"><td class="memItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a13a7039dd07811ced226e5adc29d6819">waitForAt</a> (int num, std::chrono::milliseconds timeMs) const final</td></tr>
<tr class="memdesc:a13a7039dd07811ced226e5adc29d6819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready for a maximum of 'timeMs' milliseconds.  <a href="#a13a7039dd07811ced226e5adc29d6819">More...</a><br /></td></tr>
<tr class="separator:a13a7039dd07811ced226e5adc29d6819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084c691c4873a2dd206b05ecd3e5dd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a084c691c4873a2dd206b05ecd3e5dd34">wait</a> () const final</td></tr>
<tr class="memdesc:a084c691c4873a2dd206b05ecd3e5dd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready.  <a href="#a084c691c4873a2dd206b05ecd3e5dd34">More...</a><br /></td></tr>
<tr class="separator:a084c691c4873a2dd206b05ecd3e5dd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472f64cc9dd65b058f8fcbabc4e3d02"><td class="memItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a3472f64cc9dd65b058f8fcbabc4e3d02">waitFor</a> (std::chrono::milliseconds timeMs) const final</td></tr>
<tr class="memdesc:a3472f64cc9dd65b058f8fcbabc4e3d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready for a maximum of 'timeMs' milliseconds.  <a href="#a3472f64cc9dd65b058f8fcbabc4e3d02">More...</a><br /></td></tr>
<tr class="separator:a3472f64cc9dd65b058f8fcbabc4e3d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945677eefa8942162876ddc8a96e2a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a945677eefa8942162876ddc8a96e2a3f">waitAll</a> () const final</td></tr>
<tr class="memdesc:a945677eefa8942162876ddc8a96e2a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures in the continuation chain to be ready.  <a href="#a945677eefa8942162876ddc8a96e2a3f">More...</a><br /></td></tr>
<tr class="separator:a945677eefa8942162876ddc8a96e2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d2ba69b3d5553fd009bb7cd6d507b"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:a9f6d2ba69b3d5553fd009bb7cd6d507b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b">get</a> ()</td></tr>
<tr class="memdesc:a9f6d2ba69b3d5553fd009bb7cd6d507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value associated with this context.  <a href="#a9f6d2ba69b3d5553fd009bb7cd6d507b">More...</a><br /></td></tr>
<tr class="separator:a9f6d2ba69b3d5553fd009bb7cd6d507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc148b852493915dfa3925f4d8ca80e4"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:afc148b852493915dfa3925f4d8ca80e4"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#afc148b852493915dfa3925f4d8ca80e4">getRef</a> () const</td></tr>
<tr class="memdesc:afc148b852493915dfa3925f4d8ca80e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference the future value associated with this context.  <a href="#afc148b852493915dfa3925f4d8ca80e4">More...</a><br /></td></tr>
<tr class="separator:afc148b852493915dfa3925f4d8ca80e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf24cac3dcdf0bf21b7301e606fa4d1a"><td class="memTemplParams" colspan="2">template&lt;class V , class  = NonBufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:aaf24cac3dcdf0bf21b7301e606fa4d1a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aaf24cac3dcdf0bf21b7301e606fa4d1a">set</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:aaf24cac3dcdf0bf21b7301e606fa4d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the promised value associated with this context.  <a href="#aaf24cac3dcdf0bf21b7301e606fa4d1a">More...</a><br /></td></tr>
<tr class="separator:aaf24cac3dcdf0bf21b7301e606fa4d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc68322709515d1586cf453276f2100"><td class="memTemplParams" colspan="2">template&lt;class V , class  = BufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:a6cc68322709515d1586cf453276f2100"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6cc68322709515d1586cf453276f2100">push</a> (V &amp;&amp;value)</td></tr>
<tr class="memdesc:a6cc68322709515d1586cf453276f2100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a single value into the promise buffer.  <a href="#a6cc68322709515d1586cf453276f2100">More...</a><br /></td></tr>
<tr class="separator:a6cc68322709515d1586cf453276f2100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7d6dac6001c2f0fd9da6934e81440"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:a92e7d6dac6001c2f0fd9da6934e81440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a92e7d6dac6001c2f0fd9da6934e81440">pull</a> (bool &amp;isBufferClosed)</td></tr>
<tr class="memdesc:a92e7d6dac6001c2f0fd9da6934e81440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull a single value from the future buffer.  <a href="#a92e7d6dac6001c2f0fd9da6934e81440">More...</a><br /></td></tr>
<tr class="separator:a92e7d6dac6001c2f0fd9da6934e81440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b19af9520df4882b8d1f9a0f9ad0c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:ac90b19af9520df4882b8d1f9a0f9ad0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac90b19af9520df4882b8d1f9a0f9ad0c">getAt</a> (int num)</td></tr>
<tr class="memdesc:ac90b19af9520df4882b8d1f9a0f9ad0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value from the 'num-th' continuation context.  <a href="#ac90b19af9520df4882b8d1f9a0f9ad0c">More...</a><br /></td></tr>
<tr class="separator:ac90b19af9520df4882b8d1f9a0f9ad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f03e8a60cefa9aed0d9de63fcc63452"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a3f03e8a60cefa9aed0d9de63fcc63452"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a3f03e8a60cefa9aed0d9de63fcc63452">getRefAt</a> (int num) const</td></tr>
<tr class="memdesc:a3f03e8a60cefa9aed0d9de63fcc63452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the future value from the 'num-th' continuation context.  <a href="#a3f03e8a60cefa9aed0d9de63fcc63452">More...</a><br /></td></tr>
<tr class="separator:a3f03e8a60cefa9aed0d9de63fcc63452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b5235e7557b88a9b044ed030ff95fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a45b5235e7557b88a9b044ed030ff95fd">waitAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const final</td></tr>
<tr class="memdesc:a45b5235e7557b88a9b044ed030ff95fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready.  <a href="#a45b5235e7557b88a9b044ed030ff95fd">More...</a><br /></td></tr>
<tr class="separator:a45b5235e7557b88a9b044ed030ff95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fecdd49135f75ed831a4bb2c327624"><td class="memItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac1fecdd49135f75ed831a4bb2c327624">waitForAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, std::chrono::milliseconds timeMs) const final</td></tr>
<tr class="memdesc:ac1fecdd49135f75ed831a4bb2c327624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future in the 'num-th' continuation context to be ready for a maximum of 'timeMs' milliseconds.  <a href="#ac1fecdd49135f75ed831a4bb2c327624">More...</a><br /></td></tr>
<tr class="separator:ac1fecdd49135f75ed831a4bb2c327624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582bc9f706d742f3473de0f02ff026f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2582bc9f706d742f3473de0f02ff026f">wait</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const final</td></tr>
<tr class="memdesc:a2582bc9f706d742f3473de0f02ff026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready.  <a href="#a2582bc9f706d742f3473de0f02ff026f">More...</a><br /></td></tr>
<tr class="separator:a2582bc9f706d742f3473de0f02ff026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fb2f29e07cd1d5dc185370166605f2"><td class="memItemLeft" align="right" valign="top">std::future_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a39fb2f29e07cd1d5dc185370166605f2">waitFor</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, std::chrono::milliseconds timeMs) const final</td></tr>
<tr class="memdesc:a39fb2f29e07cd1d5dc185370166605f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the future associated with this context to be ready for a maximum of 'timeMs' milliseconds.  <a href="#a39fb2f29e07cd1d5dc185370166605f2">More...</a><br /></td></tr>
<tr class="separator:a39fb2f29e07cd1d5dc185370166605f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06361967cff0da813090d5d19816141b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a06361967cff0da813090d5d19816141b">waitAll</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const final</td></tr>
<tr class="memdesc:a06361967cff0da813090d5d19816141b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures in the continuation chain to be ready.  <a href="#a06361967cff0da813090d5d19816141b">More...</a><br /></td></tr>
<tr class="separator:a06361967cff0da813090d5d19816141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30a62675d2c29f3f62780cadbed8d0a"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:ad30a62675d2c29f3f62780cadbed8d0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad30a62675d2c29f3f62780cadbed8d0a">get</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="memdesc:ad30a62675d2c29f3f62780cadbed8d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value associated with this context.  <a href="#ad30a62675d2c29f3f62780cadbed8d0a">More...</a><br /></td></tr>
<tr class="separator:ad30a62675d2c29f3f62780cadbed8d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a1b88bfd1fb6afcd8ccb8b2921d97"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:ae31a1b88bfd1fb6afcd8ccb8b2921d97"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ae31a1b88bfd1fb6afcd8ccb8b2921d97">getRef</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const</td></tr>
<tr class="memdesc:ae31a1b88bfd1fb6afcd8ccb8b2921d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference the future value associated with this context.  <a href="#ae31a1b88bfd1fb6afcd8ccb8b2921d97">More...</a><br /></td></tr>
<tr class="separator:ae31a1b88bfd1fb6afcd8ccb8b2921d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef88ac81d0b8a34e2d73ba203b0deec1"><td class="memTemplParams" colspan="2">template&lt;class V , class  = NonBufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:aef88ac81d0b8a34e2d73ba203b0deec1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aef88ac81d0b8a34e2d73ba203b0deec1">set</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, V &amp;&amp;value)</td></tr>
<tr class="separator:aef88ac81d0b8a34e2d73ba203b0deec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c0b6b66c3b64263ebfa5c512be2f79"><td class="memTemplParams" colspan="2">template&lt;class V , class  = BufferType&lt;RET,V&gt;&gt; </td></tr>
<tr class="memitem:a38c0b6b66c3b64263ebfa5c512be2f79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a38c0b6b66c3b64263ebfa5c512be2f79">push</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, V &amp;&amp;value)</td></tr>
<tr class="separator:a38c0b6b66c3b64263ebfa5c512be2f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae946ad090fec1eb3ab2b37b7d958225d"><td class="memTemplParams" colspan="2">template&lt;class V  = RET&gt; </td></tr>
<tr class="memitem:ae946ad090fec1eb3ab2b37b7d958225d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ae946ad090fec1eb3ab2b37b7d958225d">pull</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, bool &amp;isBufferClosed)</td></tr>
<tr class="memdesc:ae946ad090fec1eb3ab2b37b7d958225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull a single value from the future buffer.  <a href="#ae946ad090fec1eb3ab2b37b7d958225d">More...</a><br /></td></tr>
<tr class="separator:ae946ad090fec1eb3ab2b37b7d958225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e8e50aaf33e2f10b8343ff6f8bd7cb"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:ad2e8e50aaf33e2f10b8343ff6f8bd7cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad2e8e50aaf33e2f10b8343ff6f8bd7cb">getAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="memdesc:ad2e8e50aaf33e2f10b8343ff6f8bd7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value from the 'num-th' continuation context.  <a href="#ad2e8e50aaf33e2f10b8343ff6f8bd7cb">More...</a><br /></td></tr>
<tr class="separator:ad2e8e50aaf33e2f10b8343ff6f8bd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aadfc75a4cd426986fb008af86ed6f9"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a8aadfc75a4cd426986fb008af86ed6f9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a8aadfc75a4cd426986fb008af86ed6f9">getRefAt</a> (int num, <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync) const</td></tr>
<tr class="memdesc:a8aadfc75a4cd426986fb008af86ed6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the future value from the 'num-th' continuation context.  <a href="#a8aadfc75a4cd426986fb008af86ed6f9">More...</a><br /></td></tr>
<tr class="separator:a8aadfc75a4cd426986fb008af86ed6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37184c0fbeb026630cbc4949b7d0670"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:ab37184c0fbeb026630cbc4949b7d0670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ab37184c0fbeb026630cbc4949b7d0670">getPrev</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="separator:ab37184c0fbeb026630cbc4949b7d0670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af8edb619ffe7d187598e874a4c20f2"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a6af8edb619ffe7d187598e874a4c20f2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6af8edb619ffe7d187598e874a4c20f2">getPrevRef</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync)</td></tr>
<tr class="separator:a6af8edb619ffe7d187598e874a4c20f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae6afb073e6d92f06c17c6d8f2048ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aeae6afb073e6d92f06c17c6d8f2048ff">setYieldHandle</a> (<a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp;<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a83acb42a49d715661b7489479a2cbd53">yield</a>) final</td></tr>
<tr class="memdesc:aeae6afb073e6d92f06c17c6d8f2048ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the underlying boost::coroutine object so that it can be yielded on.  <a href="#aeae6afb073e6d92f06c17c6d8f2048ff">More...</a><br /></td></tr>
<tr class="separator:aeae6afb073e6d92f06c17c6d8f2048ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844be164636c0bd4a97c8a60aadb9316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a844be164636c0bd4a97c8a60aadb9316">getYieldHandle</a> () final</td></tr>
<tr class="memdesc:a844be164636c0bd4a97c8a60aadb9316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the underlying boost::coroutine object.  <a href="#a844be164636c0bd4a97c8a60aadb9316">More...</a><br /></td></tr>
<tr class="separator:a844be164636c0bd4a97c8a60aadb9316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83acb42a49d715661b7489479a2cbd53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a83acb42a49d715661b7489479a2cbd53">yield</a> () final</td></tr>
<tr class="memdesc:a83acb42a49d715661b7489479a2cbd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly yields this coroutine context.  <a href="#a83acb42a49d715661b7489479a2cbd53">More...</a><br /></td></tr>
<tr class="separator:a83acb42a49d715661b7489479a2cbd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f3e3b2e513eaf80caa486d23151a61"><td class="memItemLeft" align="right" valign="top">std::atomic_int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a74f3e3b2e513eaf80caa486d23151a61">signal</a> () final</td></tr>
<tr class="memdesc:a74f3e3b2e513eaf80caa486d23151a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to the underlying synchronization variable.  <a href="#a74f3e3b2e513eaf80caa486d23151a61">More...</a><br /></td></tr>
<tr class="separator:a74f3e3b2e513eaf80caa486d23151a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7018b34b69e8283395b1bfd0e70883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#adc7018b34b69e8283395b1bfd0e70883">sleep</a> (const std::chrono::milliseconds &amp;timeMs) final</td></tr>
<tr class="memdesc:adc7018b34b69e8283395b1bfd0e70883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeps the coroutine associated with this context for <em>at least</em> 'timeMs' milliseconds or 'timeUs' microseconds depending on the overload chosen.  <a href="#adc7018b34b69e8283395b1bfd0e70883">More...</a><br /></td></tr>
<tr class="separator:adc7018b34b69e8283395b1bfd0e70883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bfae92ce436626faa71c7a49e6cdf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad5bfae92ce436626faa71c7a49e6cdf3">sleep</a> (const std::chrono::microseconds &amp;timeUs) final</td></tr>
<tr class="separator:ad5bfae92ce436626faa71c7a49e6cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c1b4501689af034dfcb9c284b8286e"><td class="memTemplParams" colspan="2">template&lt;class V  = RET, class  = BufferRetType&lt;V&gt;&gt; </td></tr>
<tr class="memitem:a60c1b4501689af034dfcb9c284b8286e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a60c1b4501689af034dfcb9c284b8286e">closeBuffer</a> ()</td></tr>
<tr class="memdesc:a60c1b4501689af034dfcb9c284b8286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a promise buffer.  <a href="#a60c1b4501689af034dfcb9c284b8286e">More...</a><br /></td></tr>
<tr class="separator:a60c1b4501689af034dfcb9c284b8286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b2fe051e1b72e6a045cb0a3e57b9d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a66b2fe051e1b72e6a045cb0a3e57b9d2">getNumCoroutineThreads</a> () const</td></tr>
<tr class="memdesc:a66b2fe051e1b72e6a045cb0a3e57b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying coroutine threads as specified in the dispatcher constructor. If -1 was passed than this number essentially indicates the number of cores.  <a href="#a66b2fe051e1b72e6a045cb0a3e57b9d2">More...</a><br /></td></tr>
<tr class="separator:a66b2fe051e1b72e6a045cb0a3e57b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5855eee0ab54a2d606cdc96196816a74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5855eee0ab54a2d606cdc96196816a74">getNumIoThreads</a> () const</td></tr>
<tr class="memdesc:a5855eee0ab54a2d606cdc96196816a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying IO threads as specified in the dispatcher constructor.  <a href="#a5855eee0ab54a2d606cdc96196816a74">More...</a><br /></td></tr>
<tr class="separator:a5855eee0ab54a2d606cdc96196816a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e2d72600c412fdeca447b9b111991c"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; int, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a70e2d72600c412fdeca447b9b111991c">getCoroQueueIdRangeForAny</a> () const</td></tr>
<tr class="memdesc:a70e2d72600c412fdeca447b9b111991c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> by the <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html" title="Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main e...">Dispatcher</a>.  <a href="#a70e2d72600c412fdeca447b9b111991c">More...</a><br /></td></tr>
<tr class="separator:a70e2d72600c412fdeca447b9b111991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac928e4597e14090fa7c79dd108e307c8"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:ac928e4597e14090fa7c79dd108e307c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8">post</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac928e4597e14090fa7c79dd108e307c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#ac928e4597e14090fa7c79dd108e307c8">More...</a><br /></td></tr>
<tr class="separator:ac928e4597e14090fa7c79dd108e307c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25741cad8e14d880665fcbe626a1cc5f"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a25741cad8e14d880665fcbe626a1cc5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a25741cad8e14d880665fcbe626a1cc5f">post</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a25741cad8e14d880665fcbe626a1cc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a25741cad8e14d880665fcbe626a1cc5f">More...</a><br /></td></tr>
<tr class="separator:a25741cad8e14d880665fcbe626a1cc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc486e2e5a28985565be243738d395b"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a2dc486e2e5a28985565be243738d395b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b">postFirst</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2dc486e2e5a28985565be243738d395b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a2dc486e2e5a28985565be243738d395b">More...</a><br /></td></tr>
<tr class="separator:a2dc486e2e5a28985565be243738d395b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234052af61bc6a306e12f5cb4baddd46"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a234052af61bc6a306e12f5cb4baddd46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a234052af61bc6a306e12f5cb4baddd46">postFirst</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a234052af61bc6a306e12f5cb4baddd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a234052af61bc6a306e12f5cb4baddd46">More...</a><br /></td></tr>
<tr class="separator:a234052af61bc6a306e12f5cb4baddd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7b792045fd293b26b4a265a713df6c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a4a7b792045fd293b26b4a265a713df6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c">then</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4a7b792045fd293b26b4a265a713df6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a4a7b792045fd293b26b4a265a713df6c">More...</a><br /></td></tr>
<tr class="separator:a4a7b792045fd293b26b4a265a713df6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16615063c053d9f5c60cbdfc2e4ca3e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:af16615063c053d9f5c60cbdfc2e4ca3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e">onError</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:af16615063c053d9f5c60cbdfc2e4ca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause.  <a href="#af16615063c053d9f5c60cbdfc2e4ca3e">More...</a><br /></td></tr>
<tr class="separator:af16615063c053d9f5c60cbdfc2e4ca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac11b61f3c2ec6f8b415239dfe8342c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a6ac11b61f3c2ec6f8b415239dfe8342c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; OTHER_RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c">finally</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ac11b61f3c2ec6f8b415239dfe8342c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.  <a href="#a6ac11b61f3c2ec6f8b415239dfe8342c">More...</a><br /></td></tr>
<tr class="separator:a6ac11b61f3c2ec6f8b415239dfe8342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671d7fb7fb234086b568a101dde84b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b">end</a> ()</td></tr>
<tr class="memdesc:a671d7fb7fb234086b568a101dde84b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the last method in a continuation chain.  <a href="#a671d7fb7fb234086b568a101dde84b0b">More...</a><br /></td></tr>
<tr class="separator:a671d7fb7fb234086b568a101dde84b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18431eacd784c497f727852c508597b5"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a18431eacd784c497f727852c508597b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a18431eacd784c497f727852c508597b5">postAsyncIo</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a18431eacd784c497f727852c508597b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an IO method to run asynchronously on the IO thread pool.  <a href="#a18431eacd784c497f727852c508597b5">More...</a><br /></td></tr>
<tr class="separator:a18431eacd784c497f727852c508597b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0559064ed7daf706dde029b2c23272d3"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a0559064ed7daf706dde029b2c23272d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a0559064ed7daf706dde029b2c23272d3">postAsyncIo</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0559064ed7daf706dde029b2c23272d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an IO function to run asynchronously on the IO thread pool.  <a href="#a0559064ed7daf706dde029b2c23272d3">More...</a><br /></td></tr>
<tr class="separator:a0559064ed7daf706dde029b2c23272d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96495b0c3e9cfc2c1ad5ece71d72365c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a96495b0c3e9cfc2c1ad5ece71d72365c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a96495b0c3e9cfc2c1ad5ece71d72365c">forEach</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a96495b0c3e9cfc2c1ad5ece71d72365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs in parallel.  <a href="#a96495b0c3e9cfc2c1ad5ece71d72365c">More...</a><br /></td></tr>
<tr class="separator:a96495b0c3e9cfc2c1ad5ece71d72365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3751b4edd7f4463e96d8a3b123c1d8c"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:ac3751b4edd7f4463e96d8a3b123c1d8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac3751b4edd7f4463e96d8a3b123c1d8c">forEach</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:ac3751b4edd7f4463e96d8a3b123c1d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel.  <a href="#ac3751b4edd7f4463e96d8a3b123c1d8c">More...</a><br /></td></tr>
<tr class="separator:ac3751b4edd7f4463e96d8a3b123c1d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733bf9fc02a6fdc40034a7e9d10de66e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a733bf9fc02a6fdc40034a7e9d10de66e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a733bf9fc02a6fdc40034a7e9d10de66e">forEachBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a733bf9fc02a6fdc40034a7e9d10de66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a733bf9fc02a6fdc40034a7e9d10de66e">More...</a><br /></td></tr>
<tr class="separator:a733bf9fc02a6fdc40034a7e9d10de66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c18cd1e2335cc5ac0dd5efea999c20b"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a5c18cd1e2335cc5ac0dd5efea999c20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a5c18cd1e2335cc5ac0dd5efea999c20b">forEachBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a5c18cd1e2335cc5ac0dd5efea999c20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a5c18cd1e2335cc5ac0dd5efea999c20b">More...</a><br /></td></tr>
<tr class="separator:a5c18cd1e2335cc5ac0dd5efea999c20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d83337fc1c9d7496a29f0e347913c5"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a44d83337fc1c9d7496a29f0e347913c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5">mapReduce</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a44d83337fc1c9d7496a29f0e347913c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of map-reduce functionality.  <a href="#a44d83337fc1c9d7496a29f0e347913c5">More...</a><br /></td></tr>
<tr class="separator:a44d83337fc1c9d7496a29f0e347913c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac0adbfbb086a16877fe6d9c5854514"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a6ac0adbfbb086a16877fe6d9c5854514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac0adbfbb086a16877fe6d9c5854514">mapReduce</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a6ac0adbfbb086a16877fe6d9c5854514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#a6ac0adbfbb086a16877fe6d9c5854514">More...</a><br /></td></tr>
<tr class="separator:a6ac0adbfbb086a16877fe6d9c5854514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cdeea67c11d6e5a3740ca315b0979b"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a86cdeea67c11d6e5a3740ca315b0979b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b">mapReduceBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a86cdeea67c11d6e5a3740ca315b0979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO.  <a href="#a86cdeea67c11d6e5a3740ca315b0979b">More...</a><br /></td></tr>
<tr class="separator:a86cdeea67c11d6e5a3740ca315b0979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada436f5169fa19522fb20591e865e95c"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:ada436f5169fa19522fb20591e865e95c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ada436f5169fa19522fb20591e865e95c">mapReduceBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:ada436f5169fa19522fb20591e865e95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#ada436f5169fa19522fb20591e865e95c">More...</a><br /></td></tr>
<tr class="separator:ada436f5169fa19522fb20591e865e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fb7062cda1aca965647f86b1c334d0"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a47fb7062cda1aca965647f86b1c334d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a47fb7062cda1aca965647f86b1c334d0">thenImpl</a> (<a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#ae01baba509e1529f4f89e01d9c19fa14">ITask::Type</a> type, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a47fb7062cda1aca965647f86b1c334d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1848dc5d7547ba112a44721951603669"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a1848dc5d7547ba112a44721951603669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a1848dc5d7547ba112a44721951603669">then</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1848dc5d7547ba112a44721951603669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a1848dc5d7547ba112a44721951603669">More...</a><br /></td></tr>
<tr class="separator:a1848dc5d7547ba112a44721951603669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311a7045f6c47e5aba887d109bb08a20"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a311a7045f6c47e5aba887d109bb08a20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a311a7045f6c47e5aba887d109bb08a20">onError</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a311a7045f6c47e5aba887d109bb08a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause.  <a href="#a311a7045f6c47e5aba887d109bb08a20">More...</a><br /></td></tr>
<tr class="separator:a311a7045f6c47e5aba887d109bb08a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad88afbd04d2ff1d325ec3f785af98"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:ad6ad88afbd04d2ff1d325ec3f785af98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad6ad88afbd04d2ff1d325ec3f785af98">finally</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad6ad88afbd04d2ff1d325ec3f785af98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.  <a href="#ad6ad88afbd04d2ff1d325ec3f785af98">More...</a><br /></td></tr>
<tr class="separator:ad6ad88afbd04d2ff1d325ec3f785af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fde2c2c762191ad18a47da842bafbd"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a72fde2c2c762191ad18a47da842bafbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a72fde2c2c762191ad18a47da842bafbd">forEach</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a72fde2c2c762191ad18a47da842bafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs in parallel.  <a href="#a72fde2c2c762191ad18a47da842bafbd">More...</a><br /></td></tr>
<tr class="separator:a72fde2c2c762191ad18a47da842bafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e31d0c16163a70fa6835d0d894488b"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a92e31d0c16163a70fa6835d0d894488b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::vector&lt; OTHER_RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a92e31d0c16163a70fa6835d0d894488b">forEach</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a92e31d0c16163a70fa6835d0d894488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel.  <a href="#a92e31d0c16163a70fa6835d0d894488b">More...</a><br /></td></tr>
<tr class="separator:a92e31d0c16163a70fa6835d0d894488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a8b62a0cc3c43ebb522b36c9f4feae"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a77a8b62a0cc3c43ebb522b36c9f4feae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a77a8b62a0cc3c43ebb522b36c9f4feae">forEachBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a77a8b62a0cc3c43ebb522b36c9f4feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a77a8b62a0cc3c43ebb522b36c9f4feae">More...</a><br /></td></tr>
<tr class="separator:a77a8b62a0cc3c43ebb522b36c9f4feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11662c98402c70d00fe38c443537ba55"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a11662c98402c70d00fe38c443537ba55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::vector&lt; std::vector&lt; OTHER_RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a11662c98402c70d00fe38c443537ba55">forEachBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a11662c98402c70d00fe38c443537ba55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a11662c98402c70d00fe38c443537ba55">More...</a><br /></td></tr>
<tr class="separator:a11662c98402c70d00fe38c443537ba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7121593247706c863a13f75de3a87e2c"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:a7121593247706c863a13f75de3a87e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a7121593247706c863a13f75de3a87e2c">mapReduce</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a7121593247706c863a13f75de3a87e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of map-reduce functionality.  <a href="#a7121593247706c863a13f75de3a87e2c">More...</a><br /></td></tr>
<tr class="separator:a7121593247706c863a13f75de3a87e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa2e2af2ef2105e2933d13370c9705"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a89aa2e2af2ef2105e2933d13370c9705"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a89aa2e2af2ef2105e2933d13370c9705">mapReduce</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a89aa2e2af2ef2105e2933d13370c9705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#a89aa2e2af2ef2105e2933d13370c9705">More...</a><br /></td></tr>
<tr class="separator:a89aa2e2af2ef2105e2933d13370c9705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa84de805a985c05658303b8ae313b50"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </td></tr>
<tr class="memitem:afa84de805a985c05658303b8ae313b50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#afa84de805a985c05658303b8ae313b50">mapReduceBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:afa84de805a985c05658303b8ae313b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO.  <a href="#afa84de805a985c05658303b8ae313b50">More...</a><br /></td></tr>
<tr class="separator:afa84de805a985c05658303b8ae313b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b14b52e110fcc608b64ba6323c32859"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:a2b14b52e110fcc608b64ba6323c32859"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2b14b52e110fcc608b64ba6323c32859">mapReduceBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a2b14b52e110fcc608b64ba6323c32859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#a2b14b52e110fcc608b64ba6323c32859">More...</a><br /></td></tr>
<tr class="separator:a2b14b52e110fcc608b64ba6323c32859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565e441cfddcbb984ce5fa22f3dbcff8"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a565e441cfddcbb984ce5fa22f3dbcff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a565e441cfddcbb984ce5fa22f3dbcff8">post</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a565e441cfddcbb984ce5fa22f3dbcff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a565e441cfddcbb984ce5fa22f3dbcff8">More...</a><br /></td></tr>
<tr class="separator:a565e441cfddcbb984ce5fa22f3dbcff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730c6f56d768eef190f1b1da2555ef00"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a730c6f56d768eef190f1b1da2555ef00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a730c6f56d768eef190f1b1da2555ef00">post</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a730c6f56d768eef190f1b1da2555ef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a730c6f56d768eef190f1b1da2555ef00">More...</a><br /></td></tr>
<tr class="separator:a730c6f56d768eef190f1b1da2555ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67969159e847e044800e7f48777534"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:add67969159e847e044800e7f48777534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#add67969159e847e044800e7f48777534">postFirst</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:add67969159e847e044800e7f48777534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#add67969159e847e044800e7f48777534">More...</a><br /></td></tr>
<tr class="separator:add67969159e847e044800e7f48777534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b509b33a26d72ff2e8e9884dfba84e5"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a3b509b33a26d72ff2e8e9884dfba84e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a3b509b33a26d72ff2e8e9884dfba84e5">postFirst</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b509b33a26d72ff2e8e9884dfba84e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts a coroutine to run asynchronously.  <a href="#a3b509b33a26d72ff2e8e9884dfba84e5">More...</a><br /></td></tr>
<tr class="separator:a3b509b33a26d72ff2e8e9884dfba84e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244e5fc4adaabf4cbf383ccffbbafe2d"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a244e5fc4adaabf4cbf383ccffbbafe2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a244e5fc4adaabf4cbf383ccffbbafe2d">postImpl</a> (int queueId, bool isHighPriority, <a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#ae01baba509e1529f4f89e01d9c19fa14">ITask::Type</a> type, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a244e5fc4adaabf4cbf383ccffbbafe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1IContextBase')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html">Bloomberg::quantum::IContextBase</a></td></tr>
<tr class="memitem:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a39a012af6799019e99e1ab5364bb2c86">~IContextBase</a> ()=default</td></tr>
<tr class="memdesc:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a39a012af6799019e99e1ab5364bb2c86">More...</a><br /></td></tr>
<tr class="separator:a39a012af6799019e99e1ab5364bb2c86 inherit pub_methods_structBloomberg_1_1quantum_1_1IContextBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ICoroContext')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a></td></tr>
<tr class="memitem:a141e79103170cb9cb0fb0197d8df61e5 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a141e79103170cb9cb0fb0197d8df61e5 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a141e79103170cb9cb0fb0197d8df61e5">getPrev</a> ()</td></tr>
<tr class="memdesc:a141e79103170cb9cb0fb0197d8df61e5 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the future value associated with the previous coroutine context in the continuation chain.  <a href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a141e79103170cb9cb0fb0197d8df61e5">More...</a><br /></td></tr>
<tr class="separator:a141e79103170cb9cb0fb0197d8df61e5 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeb2b66b620b208cde57129a9293ec3 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a7aeb2b66b620b208cde57129a9293ec3 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7aeb2b66b620b208cde57129a9293ec3">getPrevRef</a> ()</td></tr>
<tr class="memdesc:a7aeb2b66b620b208cde57129a9293ec3 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to future value associated with the previous coroutine context in the continuation chain.  <a href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7aeb2b66b620b208cde57129a9293ec3">More...</a><br /></td></tr>
<tr class="separator:a7aeb2b66b620b208cde57129a9293ec3 inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ICoroSync')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html">Bloomberg::quantum::ICoroSync</a></td></tr>
<tr class="memitem:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a870e1b03e0c0b5a2310709310b78379b">~ICoroSync</a> ()=default</td></tr>
<tr class="memdesc:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <a href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a870e1b03e0c0b5a2310709310b78379b">More...</a><br /></td></tr>
<tr class="separator:a870e1b03e0c0b5a2310709310b78379b inherit pub_methods_structBloomberg_1_1quantum_1_1ICoroSync"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ITerminate')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html">Bloomberg::quantum::ITerminate</a></td></tr>
<tr class="memitem:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a4086a8ce16fc2482ee77701d387b14d8">~ITerminate</a> ()=default</td></tr>
<tr class="memdesc:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. This function is explicitly left empty.  <a href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a4086a8ce16fc2482ee77701d387b14d8">More...</a><br /></td></tr>
<tr class="separator:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a87ea6759921b56fb473321343d84dcaf"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a87ea6759921b56fb473321343d84dcaf">operator new</a> (size_t size)</td></tr>
<tr class="separator:a87ea6759921b56fb473321343d84dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efde02f26da270afeda21feed9790c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a7efde02f26da270afeda21feed9790c8">operator delete</a> (void *p)</td></tr>
<tr class="separator:a7efde02f26da270afeda21feed9790c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe001a8f4c433d80ee93e1bdcd1a8ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#adfe001a8f4c433d80ee93e1bdcd1a8ac">deleter</a> (<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt; *p)</td></tr>
<tr class="separator:adfe001a8f4c433d80ee93e1bdcd1a8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a99f04ddc152652e7528afd95934466d1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a99f04ddc152652e7528afd95934466d1">Util</a></td></tr>
<tr class="separator:a99f04ddc152652e7528afd95934466d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7728226b6ce66782e8816b1658dd9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d6d/classclass.html">class</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aaa7728226b6ce66782e8816b1658dd9a">Task</a></td></tr>
<tr class="separator:aaa7728226b6ce66782e8816b1658dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90424f003fc2afb836709cbffa47e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d6d/classclass.html">class</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ad90424f003fc2afb836709cbffa47e2c">Dispatcher</a></td></tr>
<tr class="separator:ad90424f003fc2afb836709cbffa47e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655724ff396688037fb9bef66afc3f4e"><td class="memTemplParams" colspan="2">template&lt;class OTHER_RET &gt; </td></tr>
<tr class="memitem:a655724ff396688037fb9bef66afc3f4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d9/d6d/classclass.html">class</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a655724ff396688037fb9bef66afc3f4e">Context</a></td></tr>
<tr class="separator:a655724ff396688037fb9bef66afc3f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RET&gt;<br />
class Bloomberg::quantum::Context&lt; RET &gt;</h3>

<p>Concrete class representing a coroutine or a thread context. </p>
<dl class="section note"><dt>Note</dt><dd>For internal use only. See interfaces <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html" title="Exposes methods to manipulate the coroutine context.">ICoroContext</a> and <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html" title="Exposes methods to manipulate the thread context.">IThreadContext</a> for usage details. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a879043028bc5aeb46aa484d34d464314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879043028bc5aeb46aa484d34d464314">&#9670;&nbsp;</a></span>CoroCtx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a879043028bc5aeb46aa484d34d464314">CoroCtx</a> =  <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html">ICoroContext</a>&lt;RET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93fbe0e7fa77b4b98f35ee2935dfaa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fbe0e7fa77b4b98f35ee2935dfaa83">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;RET&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0aa527cfac3a074ace54db74a9758f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa527cfac3a074ace54db74a9758f45">&#9670;&nbsp;</a></span>ThreadCtx</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a0aa527cfac3a074ace54db74a9758f45">ThreadCtx</a> =  <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html">IThreadContext</a>&lt;RET&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27f69b3023acdc46fc3145db80ea1b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f69b3023acdc46fc3145db80ea1b68">&#9670;&nbsp;</a></span>~Context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::~<a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60c1b4501689af034dfcb9c284b8286e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c1b4501689af034dfcb9c284b8286e">&#9670;&nbsp;</a></span>closeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::closeBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a promise buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Once closed no more Pushes can be made into the buffer. The corresponding future can still Pull values until the buffer is empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7f2c171bda51b08ef7bf56f0d4aa5a90">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="adfe001a8f4c433d80ee93e1bdcd1a8ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe001a8f4c433d80ee93e1bdcd1a8ac">&#9670;&nbsp;</a></span>deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::deleter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt; *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a671d7fb7fb234086b568a101dde84b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671d7fb7fb234086b568a101dde84b0b">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt; RET &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the last method in a continuation chain. </p>
<p>This method effectively closes the continuation chain and posts the entire chain to be executed, respecting the 'queueId' and priority specified at the beginning of the chain (see <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a>). </p><dl class="section return"><dt>Returns</dt><dd>Pointer to this context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not take any functions as parameter as it is strictly used for scheduling purposes. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a6ac11b61f3c2ec6f8b415239dfe8342c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac11b61f3c2ec6f8b415239dfe8342c">&#9670;&nbsp;</a></span>finally() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must immediately precede the <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> method. This method will run regardless if any preceding coroutines have an error or not. It can be used for cleanup purposes, closing handles, terminating services, etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. After this coroutine, the <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> method must be called. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ad6ad88afbd04d2ff1d325ec3f785af98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ad88afbd04d2ff1d325ec3f785af98">&#9670;&nbsp;</a></span>finally() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::finally </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must immediately precede the <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> method. This method will run regardless if any preceding coroutines have an error or not. It can be used for cleanup purposes, closing handles, terminating services, etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. After this coroutine, the <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> method must be called. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a315aa51f354c959bca0eaee24b90a26e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a96495b0c3e9cfc2c1ad5ece71d72365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96495b0c3e9cfc2c1ad5ece71d72365c">&#9670;&nbsp;</a></span>forEach() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::vector&lt;OTHER_RET&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first element in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last element in the range (exclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1132ca05b44a667a1e3b1633e02a1b23">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ac3751b4edd7f4463e96d8a3b123c1d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3751b4edd7f4463e96d8a3b123c1d8c">&#9670;&nbsp;</a></span>forEach() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::vector&lt;OTHER_RET&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] num The number of elements to iterate over. @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a06478eb5360e23d192533370f18154bd">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a72fde2c2c762191ad18a47da842bafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fde2c2c762191ad18a47da842bafbd">&#9670;&nbsp;</a></span>forEach() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::vector&lt;OTHER_RET&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first element in the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last element in the range (exclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1132ca05b44a667a1e3b1633e02a1b23">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a92e31d0c16163a70fa6835d0d894488b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e31d0c16163a70fa6835d0d894488b">&#9670;&nbsp;</a></span>forEach() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::vector&lt;OTHER_RET&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,first+num). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] num The number of elements to iterate over. @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a06478eb5360e23d192533370f18154bd">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a733bf9fc02a6fdc40034a7e9d10de66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733bf9fc02a6fdc40034a7e9d10de66e">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab7f82d2d74ac1840dbe1332898a86796">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a5c18cd1e2335cc5ac0dd5efea999c20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c18cd1e2335cc5ac0dd5efea999c20b">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a40a9f2692cfbbb3b3cfbf38d6ec6f75e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a77a8b62a0cc3c43ebb522b36c9f4feae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a8b62a0cc3c43ebb522b36c9f4feae">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab7f82d2d74ac1840dbe1332898a86796">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a11662c98402c70d00fe38c443537ba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11662c98402c70d00fe38c443537ba55">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::vector&lt;std::vector&lt;OTHER_RET&gt; &gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; OTHER_RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt <em>does not</em> meet the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a40a9f2692cfbbb3b3cfbf38d6ec6f75e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a9f6d2ba69b3d5553fd009bb7cd6d507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d2ba69b3d5553fd009bb7cd6d507b">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value associated with this context. </p>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future becomes invalidated (i.e. cannot be read again). </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a8c969eafd7cdd1b694c33194a9dd7c09">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ad30a62675d2c29f3f62780cadbed8d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a62675d2c29f3f62780cadbed8d0a">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value associated with this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future becomes invalidated (i.e. cannot be read again). </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a330754e60be65d5ee5f73793c7f86f69">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ac90b19af9520df4882b8d1f9a0f9ad0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90b19af9520df4882b8d1f9a0f9ad0c">&#9670;&nbsp;</a></span>getAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The future value of the 'num-th' thread context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future is invalidated (i.e. cannot be read again). </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a8d04a093d07bf66ead58603592295352">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ad2e8e50aaf33e2f10b8343ff6f8bd7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e8e50aaf33e2f10b8343ff6f8bd7cb">&#9670;&nbsp;</a></span>getAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The future value of the 'num-th' coroutine context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Once this function returns, the future is invalidated (i.e. cannot be read again). </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a87a132655875ac6f07d5242e24d80a8d">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a70e2d72600c412fdeca447b9b111991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e2d72600c412fdeca447b9b111991c">&#9670;&nbsp;</a></span>getCoroQueueIdRangeForAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; int, int &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getCoroQueueIdRangeForAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> by the <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html" title="Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main e...">Dispatcher</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>queueIdRange The range of queueIds that <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> covers </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a9c60ca5034b9d1b19dd7279f3476bbec">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a66b2fe051e1b72e6a045cb0a3e57b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b2fe051e1b72e6a045cb0a3e57b9d2">&#9670;&nbsp;</a></span>getNumCoroutineThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getNumCoroutineThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of underlying coroutine threads as specified in the dispatcher constructor. If -1 was passed than this number essentially indicates the number of cores. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning coroutines to a specific queue. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a0fadac955b2b32d87d1b8e505dce39c3">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a5855eee0ab54a2d606cdc96196816a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5855eee0ab54a2d606cdc96196816a74">&#9670;&nbsp;</a></span>getNumIoThreads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getNumIoThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of underlying IO threads as specified in the dispatcher constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning IO tasks to a specific queue. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a1efdbf7df3818aec9bc8fd98a5bfc640">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ab37184c0fbeb026630cbc4949b7d0670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37184c0fbeb026630cbc4949b7d0670">&#9670;&nbsp;</a></span>getPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6af8edb619ffe7d187598e874a4c20f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af8edb619ffe7d187598e874a4c20f2">&#9670;&nbsp;</a></span>getPrevRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getPrevRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc148b852493915dfa3925f4d8ca80e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc148b852493915dfa3925f4d8ca80e4">&#9670;&nbsp;</a></span>getRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference the future value associated with this context. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a>, this function does not invalidate the future and as such may be read again. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a2eed7d5de4d43b5c5c214cb38b239acd">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ae31a1b88bfd1fb6afcd8ccb8b2921d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31a1b88bfd1fb6afcd8ccb8b2921d97">&#9670;&nbsp;</a></span>getRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; V &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference the future value associated with this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a>, this function does not invalidate the future and as such may be read again. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a43cf7ed9f70bc0123547b6baa6ec7c49">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3f03e8a60cefa9aed0d9de63fcc63452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f03e8a60cefa9aed0d9de63fcc63452">&#9670;&nbsp;</a></span>getRefAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getRefAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value of the 'num-th' thread context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac90b19af9520df4882b8d1f9a0f9ad0c" title="Get the future value from the &#39;num-th&#39; continuation context.">getAt()</a> this function will not invalidate the future and as such it can be read again. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a5456b3de0627bee9695946acf745e195">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a8aadfc75a4cd426986fb008af86ed6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aadfc75a4cd426986fb008af86ed6f9">&#9670;&nbsp;</a></span>getRefAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a0a7dd2b5f475bbecb11bfa87fcc251c5">NonBufferRetType</a>&lt; OTHER_RET &gt; &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getRefAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the future value from the 'num-th' continuation context. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a9f6d2ba69b3d5553fd009bb7cd6d507b" title="Get the future value associated with this context.">get()</a> or getAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>The type of the future value associated with the 'num-th' context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the future value of the 'num-th' coroutine context. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. Contrary to <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac90b19af9520df4882b8d1f9a0f9ad0c" title="Get the future value from the &#39;num-th&#39; continuation context.">getAt()</a> this function will not invalidate the future and as such it can be read again. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3c64853ee6c868f4e83668f17d4efd95">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a71819413eb6ab86661343d31e5ba9acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71819413eb6ab86661343d31e5ba9acb">&#9670;&nbsp;</a></span>getTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#a6c5b8216547b11f3f0e0e6bc7d20956d">ITask::Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html#a780f5e8ec1dca092e003d747a602ba0e">Bloomberg::quantum::ITaskAccessor</a>.</p>

</div>
</div>
<a id="a844be164636c0bd4a97c8a60aadb9316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844be164636c0bd4a97c8a60aadb9316">&#9670;&nbsp;</a></span>getYieldHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::getYieldHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the underlying boost::coroutine object. </p>
<dl class="section return"><dt>Returns</dt><dd>The associated boost::coroutine object held by this class. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the underlying boost::coroutine is not set. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#afd376fdf2aa4ffd80ae46f0c87bd3400">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<a id="a8db6bb1798fc7c74534648e2091ad5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db6bb1798fc7c74534648e2091ad5be">&#9670;&nbsp;</a></span>isBlocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::isBlocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html#a4d09505d42ce1edc2fffa37f15e47add">Bloomberg::quantum::ITaskAccessor</a>.</p>

</div>
</div>
<a id="addfd8c1fdeb5ca8594a2af08dd74c7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd8c1fdeb5ca8594a2af08dd74c7ca">&#9670;&nbsp;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::isSleeping </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateTimer</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html#a949ab7b13d0cbef538f6fbf14175da70">Bloomberg::quantum::ITaskAccessor</a>.</p>

</div>
</div>
<a id="a44d83337fc1c9d7496a29f0e347913c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d83337fc1c9d7496a29f0e347913c5">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of map-reduce functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KEY</td><td>The KEY type used for mapping and reducing. </td></tr>
    <tr><td class="paramname">MAPPED_TYPE</td><td>The output type after a map operation. </td></tr>
    <tr><td class="paramname">REDUCED_TYPE</td><td>The output type after a reduce operation. </td></tr>
    <tr><td class="paramname">MAPPER_FUNC</td><td>The mapper function having the signature 'std::vector&lt;std::pair&lt;KEY,MAPPED_TYPE&gt;&gt;(*INPUT_IT)' </td></tr>
    <tr><td class="paramname">REDUCER_FUNC</td><td>The reducer function having the signature 'std::pair&lt;KEY,REDUCED_TYPE&gt;(std::pair&lt;KEY, std::vector&lt;MAPPED_TYPE&gt;&gt;&amp;&amp;)' </td></tr>
    <tr><td class="paramname">INPUT_IT</td><td>The iterator type. @oaram[in] first The start iterator to a list of items to be processed in the range [first,last). @oaram[in] last The end iterator to a list of items (not inclusive). @oaram[in] mapper The mapper function. @oaram[in] reducer The reducer function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to a reduced map of values. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a6ac0adbfbb086a16877fe6d9c5854514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac0adbfbb086a16877fe6d9c5854514">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#af26ac90a03f5a15b231732597f0c311e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a7121593247706c863a13f75de3a87e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7121593247706c863a13f75de3a87e2c">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of map-reduce functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KEY</td><td>The KEY type used for mapping and reducing. </td></tr>
    <tr><td class="paramname">MAPPED_TYPE</td><td>The output type after a map operation. </td></tr>
    <tr><td class="paramname">REDUCED_TYPE</td><td>The output type after a reduce operation. </td></tr>
    <tr><td class="paramname">MAPPER_FUNC</td><td>The mapper function having the signature 'std::vector&lt;std::pair&lt;KEY,MAPPED_TYPE&gt;&gt;(*INPUT_IT)' </td></tr>
    <tr><td class="paramname">REDUCER_FUNC</td><td>The reducer function having the signature 'std::pair&lt;KEY,REDUCED_TYPE&gt;(std::pair&lt;KEY, std::vector&lt;MAPPED_TYPE&gt;&gt;&amp;&amp;)' </td></tr>
    <tr><td class="paramname">INPUT_IT</td><td>The iterator type. @oaram[in] first The start iterator to a list of items to be processed in the range [first,last). @oaram[in] last The end iterator to a list of items (not inclusive). @oaram[in] mapper The mapper function. @oaram[in] reducer The reducer function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to a reduced map of values. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a876d52748c66869620cdb9753783a86e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a89aa2e2af2ef2105e2933d13370c9705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89aa2e2af2ef2105e2933d13370c9705">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#af26ac90a03f5a15b231732597f0c311e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a86cdeea67c11d6e5a3740ca315b0979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cdeea67c11d6e5a3740ca315b0979b">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO. </p>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afa8065d1270e5205c09720d1faf5307a">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ada436f5169fa19522fb20591e865e95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada436f5169fa19522fb20591e865e95c">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3d6b21c20bc63231bc2ad1e847079183">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="afa84de805a985c05658303b8ae313b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa84de805a985c05658303b8ae313b50">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a44d83337fc1c9d7496a29f0e347913c5" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO. </p>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afa8065d1270e5205c09720d1faf5307a">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a2b14b52e110fcc608b64ba6323c32859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b14b52e110fcc608b64ba6323c32859">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;std::map&lt;KEY, REDUCED_TYPE&gt; &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a86cdeea67c11d6e5a3740ca315b0979b" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3d6b21c20bc63231bc2ad1e847079183">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="af16615063c053d9f5c60cbdfc2e4ca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16615063c053d9f5c60cbdfc2e4ca3e">&#9670;&nbsp;</a></span>onError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::onError </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must follow <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> method. This method will conditionally run if-and-only-if any previous coroutines in the continuation chain return an error or throw. When a coroutine which is part of a continuation chain has an error, all subsequent <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> methods are skipped and if <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> is provided it will be called. If there are no errors, this method is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function is non-blocking. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a311a7045f6c47e5aba887d109bb08a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311a7045f6c47e5aba887d109bb08a20">&#9670;&nbsp;</a></span>onError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::onError </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts as as a 'catch' clause. </p>
<p>This function is optional for the continuation chain and may be called at most once. If called, it must follow <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> method. This method will conditionally run if-and-only-if any previous coroutines in the continuation chain return an error or throw. When a coroutine which is part of a continuation chain has an error, all subsequent <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> methods are skipped and if <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> is provided it will be called. If there are no errors, this method is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function is non-blocking. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#abc0fd314e1dbc93055a0107c390b8af9">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a7efde02f26da270afeda21feed9790c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efde02f26da270afeda21feed9790c8">&#9670;&nbsp;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87ea6759921b56fb473321343d84dcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ea6759921b56fb473321343d84dcaf">&#9670;&nbsp;</a></span>operator new()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac928e4597e14090fa7c79dd108e307c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac928e4597e14090fa7c79dd108e307c8">&#9670;&nbsp;</a></span>post() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<dl class="section attention"><dt>Attention</dt><dd>Continuation methods are typically chained in the following manner and must follow the relative placement below. <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> are the only mandatory methods. <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> can be called at most once, whereas <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> may be called zero or more times.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afda4bb817480a24960e407f6e977ed28">ICoroContext&lt;RET&gt;::Ptr</a> ctx = <a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">ICoroContext::postFirst</a>()-&gt;then()-&gt;...-&gt;then()-&gt;onError()-&gt;finally()-&gt;end();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> methods are standalone and do not allow continuations.</dd></dl>
<p>This method will post the coroutine on any thread available. Typically it will pick one which has the smallest number of concurrent coroutines executing at the time of the post. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a25741cad8e14d880665fcbe626a1cc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25741cad8e14d880665fcbe626a1cc5f">&#9670;&nbsp;</a></span>post() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on the specified queue (thread) with high or low priority. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7012d092efbd20c729b3c150facb97bb">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a565e441cfddcbb984ce5fa22f3dbcff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565e441cfddcbb984ce5fa22f3dbcff8">&#9670;&nbsp;</a></span>post() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<dl class="section attention"><dt>Attention</dt><dd>Continuation methods are typically chained in the following manner and must follow the relative placement below. <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a> are the only mandatory methods. <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> can be called at most once, whereas <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> may be called zero or more times.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#afda4bb817480a24960e407f6e977ed28">ICoroContext&lt;RET&gt;::Ptr</a> ctx = <a class="code" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">ICoroContext::postFirst</a>()-&gt;then()-&gt;...-&gt;then()-&gt;onError()-&gt;finally()-&gt;end();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> methods are standalone and do not allow continuations.</dd></dl>
<p>This method will post the coroutine on any thread available. Typically it will pick one which has the smallest number of concurrent coroutines executing at the time of the post. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7e16a0f4dda08ea619bbd3997f31a51e">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a730c6f56d768eef190f1b1da2555ef00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c6f56d768eef190f1b1da2555ef00">&#9670;&nbsp;</a></span>post() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on the specified queue (thread) with high or low priority. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context cannot be used to chain further coroutines. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a7012d092efbd20c729b3c150facb97bb">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a18431eacd784c497f727852c508597b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18431eacd784c497f727852c508597b5">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts an IO method to run asynchronously on the IO thread pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this function. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine future object which may be used to retrieve the result of the IO operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not block. The passed function will not be wrapped in a coroutine. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#aafa32c808db9c73262f5336b03f2055a">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a0559064ed7daf706dde029b2c23272d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0559064ed7daf706dde029b2c23272d3">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a294434a555befbec5230f5ff03944878">CoroFuturePtr</a>&lt; OTHER_RET &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts an IO function to run asynchronously on the IO thread pool. </p>
<p>This method will post the function on the specified queue (thread) with high or low priority. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this function. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this function should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a18431eacd784c497f727852c508597b5" title="Posts an IO method to run asynchronously on the IO thread pool.">postAsyncIo()</a> above. Valid range is [0, numIoThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> is disallowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the function will be scheduled to run immediately after the currently executing function on 'queueId' has completed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine future object which may be used to retrieve the result of the IO operation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method does not block. The passed function will not be wrapped in a coroutine. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a03a77b36de1443b63583e4217e33fb62">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a2dc486e2e5a28985565be243738d395b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc486e2e5a28985565be243738d395b">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a234052af61bc6a306e12f5cb4baddd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234052af61bc6a306e12f5cb4baddd46">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3ca0bf6a7feb401d3f3c82518cf54b06">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="add67969159e847e044800e7f48777534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add67969159e847e044800e7f48777534">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a4563ab7eb43249f2ad8677935b0b002c">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a3b509b33a26d72ff2e8e9884dfba84e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b509b33a26d72ff2e8e9884dfba84e5">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postFirst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is the head of a coroutine continuation chain and must be called only once in the chain. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#ac928e4597e14090fa7c79dd108e307c8" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads), <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a>. When using <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> as input, the current queueId of this execution context will be preserved for the posted coroutine thus enabling to write lock-free code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a3ca0bf6a7feb401d3f3c82518cf54b06">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a244e5fc4adaabf4cbf383ccffbbafe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244e5fc4adaabf4cbf383ccffbbafe2d">&#9670;&nbsp;</a></span>postImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::postImpl </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#ae01baba509e1529f4f89e01d9c19fa14">ITask::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92e7d6dac6001c2f0fd9da6934e81440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e7d6dac6001c2f0fd9da6934e81440">&#9670;&nbsp;</a></span>pull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::pull </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isBufferClosed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull a single value from the future buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
    <tr><td class="paramname">V</td><td>The type of value contained in <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">isBufferClosed</td><td>Indicates if this buffer is closed and no more Pull operations are allowed on it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next value pulled out from the front of the buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Method available for buffered futures only. Blocks until one value is retrieved from the buffer. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a65ced94956cdfff4ad094897b14f8234">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ae946ad090fec1eb3ab2b37b7d958225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae946ad090fec1eb3ab2b37b7d958225d">&#9670;&nbsp;</a></span>pull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a3e3f89ff8206c0514976b423cb7199cd">BufferRetType</a>&lt; V &gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::pull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isBufferClosed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull a single value from the future buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
    <tr><td class="paramname">V</td><td>The type of value contained in <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isBufferClosed</td><td>Indicates if this buffer is closed and no more Pull operations are allowed on it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next value pulled out from the front of the buffer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Method available for buffered futures only. Blocks until one value is retrieved from the buffer. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a218dc6b764b01a685e37840a796fe0eb">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a6cc68322709515d1586cf453276f2100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc68322709515d1586cf453276f2100">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::push </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a single value into the promise buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BUF</td><td>Represents a class of type <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
    <tr><td class="paramname">V</td><td>The type of value contained in <a class="el" href="../../d1/d87/classBloomberg_1_1quantum_1_1Buffer.html" title="Container which allows buffered access to a series of values. Values are pushed-in (written) by a pro...">Buffer</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push at the end of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Method available for buffered futures only. Never blocks. Once the buffer is closed, no more Push operations are allowed. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a18a76d5a8b8d68567bf706f468d69ea2">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a38c0b6b66c3b64263ebfa5c512be2f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c0b6b66c3b64263ebfa5c512be2f79">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf24cac3dcdf0bf21b7301e606fa4d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf24cac3dcdf0bf21b7301e606fa4d1a">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::set </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the promised value associated with this context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type of the promised value. This should be implicitly deduced by the compiler and should always == RET. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A reference to the value (l-value or r-value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Never blocks. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a984eea6da10575adfba1a38d3b09ebd7">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="aef88ac81d0b8a34e2d73ba203b0deec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef88ac81d0b8a34e2d73ba203b0deec1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<div class="memtemplate">
template&lt;class V , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a71ccef08af22fdde662e7df560dccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a71ccef08af22fdde662e7df560dccb">&#9670;&nbsp;</a></span>setException()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::setException </td>
          <td>(</td>
          <td class="paramtype">std::exception_ptr&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an exception in the promise associated with the current <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html" title="Exposes methods to manipulate the thread context.">IThreadContext</a> or <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html" title="Exposes methods to manipulate the coroutine context.">ICoroContext</a>. </p>
<p>When setting an exception inside a promise, any attempt to read a value from the associated future will re-throw this exception. Any threads or coroutines already blocked on this future will immediately unblock and re-throw. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ex</td><td>An exception pointer which has been caught via std::current_exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

<p>Implements <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a084048c88d90de4f3797f18fb3c5fcc4">Bloomberg::quantum::IContextBase</a>.</p>

</div>
</div>
<a id="ae5a828ab3f18b336f310191e04bae154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a828ab3f18b336f310191e04bae154">&#9670;&nbsp;</a></span>setTask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::setTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#a6c5b8216547b11f3f0e0e6bc7d20956d">ITask::Ptr</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d0/d96/structBloomberg_1_1quantum_1_1ITaskAccessor.html#ae5688aafae4ee70f1dbcc3c732c05c83">Bloomberg::quantum::ITaskAccessor</a>.</p>

</div>
</div>
<a id="aeae6afb073e6d92f06c17c6d8f2048ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae6afb073e6d92f06c17c6d8f2048ff">&#9670;&nbsp;</a></span>setYieldHandle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::setYieldHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d86/structBloomberg_1_1quantum_1_1Traits.html#a2730a4e218f1af1a4e3f64e80ed7bbfc">Traits::Yield</a> &amp;&#160;</td>
          <td class="paramname"><em>yield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the underlying boost::coroutine object so that it can be yielded on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yield</td><td>Reference to the boost::coroutine object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a9639b1f2fad78e3d308bec878a5687f2">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<a id="a74f3e3b2e513eaf80caa486d23151a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f3e3b2e513eaf80caa486d23151a61">&#9670;&nbsp;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_int &amp; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor to the underlying synchronization variable. </p>
<dl class="section return"><dt>Returns</dt><dd>An atomic integer used to synchronize with other primitive types. </dd></dl>

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a1fc5a457c395fd7843ab36de74821fdd">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<a id="adc7018b34b69e8283395b1bfd0e70883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7018b34b69e8283395b1bfd0e70883">&#9670;&nbsp;</a></span>sleep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::sleep </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sleeps the coroutine associated with this context for <em>at least</em> 'timeMs' milliseconds or 'timeUs' microseconds depending on the overload chosen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMs/timeUs</td><td>Time to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method yields the coroutine until the timer has expired. Depending on the coroutine load on the particular running thread, this method may sleep longer. </dd></dl>

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a89a2eac3a5f775a2f7306c3d4a10d631">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<a id="ad5bfae92ce436626faa71c7a49e6cdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bfae92ce436626faa71c7a49e6cdf3">&#9670;&nbsp;</a></span>sleep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::sleep </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>timeUs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#ad20289c9f85157b6d76b46aefe401436">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<a id="a8bac8f4101d8469756bb27b1c0b7f9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bac8f4101d8469756bb27b1c0b7f9dc">&#9670;&nbsp;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminates the object. </p>
<dl class="section note"><dt>Note</dt><dd>This method should contain all logic necessary to properly cleanup this instance. </dd></dl>

<p>Implements <a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a66e42ce854b5afbb7742c5ffdaae8503">Bloomberg::quantum::ITerminate</a>.</p>

</div>
</div>
<a id="a4a7b792045fd293b26b4a265a713df6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7b792045fd293b26b4a265a713df6c">&#9670;&nbsp;</a></span>then() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a>&lt;OTHER_RET&gt;::<a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#ac92e5d294479f777fd01f5621e4f8db9">Ptr</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::then </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is optional for the continuation chain and may be called 0 or more times. If called, it must follow <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> method. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and runs when all previous chained coroutines have completed. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a1848dc5d7547ba112a44721951603669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1848dc5d7547ba112a44721951603669">&#9670;&nbsp;</a></span>then() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::then </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts a coroutine to run asynchronously. </p>
<p>This function is optional for the continuation chain and may be called 0 or more times. If called, it must follow <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a2dc486e2e5a28985565be243738d395b" title="Posts a coroutine to run asynchronously.">postFirst()</a> or another <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a> method. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OTHER_RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a coroutine context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and runs when all previous chained coroutines have completed. The returned context can be used to chain further coroutines. Possible method calls following this are <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a4a7b792045fd293b26b4a265a713df6c" title="Posts a coroutine to run asynchronously.">then()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#af16615063c053d9f5c60cbdfc2e4ca3e" title="Posts a coroutine to run asynchronously. This is the error handler for a continuation chain and acts ...">onError()</a>, <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a6ac11b61f3c2ec6f8b415239dfe8342c" title="Posts a coroutine to run asynchronously. This coroutine is always guaranteed to run.">finally()</a> and <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>. </dd></dl>

<p>Implements <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#a122f96fbe956dcc2205564b1e953d8fc">Bloomberg::quantum::ICoroContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a47fb7062cda1aca965647f86b1c334d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fb7062cda1aca965647f86b1c334d0">&#9670;&nbsp;</a></span>thenImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a97424bb463a112d6dd7606741b20e484">ContextPtr</a>&lt;OTHER_RET&gt; <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::thenImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/daf/structBloomberg_1_1quantum_1_1ITask.html#ae01baba509e1529f4f89e01d9c19fa14">ITask::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef705383af39db02acc63c0dd8e4a321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef705383af39db02acc63c0dd8e4a321">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the future object associated with this context has a valid shared state with the corresponding promise. </p>
<dl class="section return"><dt>Returns</dt><dd>True if valid, false otherwise. </dd></dl>

<p>Implements <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a022df5fbd098b18058823ac74e4491d1">Bloomberg::quantum::IContextBase</a>.</p>

</div>
</div>
<a id="ab23416d558addcca3ba223c3ff689672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23416d558addcca3ba223c3ff689672">&#9670;&nbsp;</a></span>validAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::validAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the future object associated with the 'num'-th continuation context is still valid. </p>
<p>When using coroutine continuations, any future in the continuation chain can be validated using this function. Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#aef705383af39db02acc63c0dd8e4a321" title="Determines if the future object associated with this context has a valid shared state with the corres...">valid()</a> or validAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a3a0a83b7941b8b0cf2c0a9ce6ec0f7ab" title="This is the last method in a continuation chain.">IThreadContext::end()</a> or <a class="el" href="../../d5/dd1/structBloomberg_1_1quantum_1_1ICoroContext.html#ab2530e5e0231aaba5a2f06315f713300" title="This is the last method in a continuation chain.">ICoroContext::end()</a>). Position 0 represents the first future in the chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to validate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if valid, false otherwise. </dd></dl>

<p>Implements <a class="el" href="../../d8/db0/structBloomberg_1_1quantum_1_1IContextBase.html#a5cb482148c731b5b9d6866d7e57f962f">Bloomberg::quantum::IContextBase</a>.</p>

</div>
</div>
<a id="a084c691c4873a2dd206b05ecd3e5dd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084c691c4873a2dd206b05ecd3e5dd34">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future associated with this context to be ready. </p>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a61b2eb7438e46915e411d3fd7e96b82d">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a2582bc9f706d742f3473de0f02ff026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582bc9f706d742f3473de0f02ff026f">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future associated with this context to be ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the future is ready or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a6790f4caa9b032241c715803201561f4">Bloomberg::quantum::ICoroContextBase</a>.</p>

</div>
</div>
<a id="a945677eefa8942162876ddc8a96e2a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945677eefa8942162876ddc8a96e2a3f">&#9670;&nbsp;</a></span>waitAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures in the continuation chain to be ready. </p>
<dl class="section note"><dt>Note</dt><dd>Blocks until all future values are ready. If any future throws, the exception is swallowed. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a4724f410e1d41c185f46ad394ad3bbe2">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a06361967cff0da813090d5d19816141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06361967cff0da813090d5d19816141b">&#9670;&nbsp;</a></span>waitAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures in the continuation chain to be ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until all future values are ready. If any future throws, the exception is swallowed. </dd></dl>

<p>Implements <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a63d57113242dd466201d5e62a7b42cf8">Bloomberg::quantum::ICoroContextBase</a>.</p>

</div>
</div>
<a id="ac89818fc8478508cad80c6cdb833e2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89818fc8478508cad80c6cdb833e2dd">&#9670;&nbsp;</a></span>waitAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future in the 'num-th' continuation context to be ready. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a084c691c4873a2dd206b05ecd3e5dd34" title="Waits for the future associated with this context to be ready.">wait()</a> or waitAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready or an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#ac31560ef1209af2c86a76260dd70b189">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a45b5235e7557b88a9b044ed030ff95fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b5235e7557b88a9b044ed030ff95fd">&#9670;&nbsp;</a></span>waitAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future in the 'num-th' continuation context to be ready. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a084c691c4873a2dd206b05ecd3e5dd34" title="Waits for the future associated with this context to be ready.">wait()</a> or waitAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready or an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a3cbd4fbaab81b30ae8a8ef2eaf7978bc">Bloomberg::quantum::ICoroContextBase</a>.</p>

</div>
</div>
<a id="a3472f64cc9dd65b058f8fcbabc4e3d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3472f64cc9dd65b058f8fcbabc4e3d02">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitFor </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeMs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future associated with this context to be ready for a maximum of 'timeMs' milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMs</td><td>The maximum amount of milliseconds to wait until the future value becomes ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'ready' if value was posted before duration expired or 'timeout' otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready, until 'timeMs' duration expires or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a0bb2b08d8b6688e2186aaf3afb394dae">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="a39fb2f29e07cd1d5dc185370166605f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fb2f29e07cd1d5dc185370166605f2">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future associated with this context to be ready for a maximum of 'timeMs' milliseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMs</td><td>The maximum amount of milliseconds to wait until the future value becomes ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'ready' if value was posted before duration expired or 'timeout' otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready, until 'timeMs' duration expires or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#ac07fda0dfbf94d1c611118d0eb77a275">Bloomberg::quantum::ICoroContextBase</a>.</p>

</div>
</div>
<a id="a13a7039dd07811ced226e5adc29d6819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a7039dd07811ced226e5adc29d6819">&#9670;&nbsp;</a></span>waitForAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitForAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future in the 'num-th' continuation context to be ready for a maximum of 'timeMs' milliseconds. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a084c691c4873a2dd206b05ecd3e5dd34" title="Waits for the future associated with this context to be ready.">wait()</a> or waitAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMs</td><td>The maximum amount of milliseconds to wait until the future value becomes ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'ready' if value was posted before duration expired or 'timeout' otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready, until 'timeMs' duration expires or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../da/de3/structBloomberg_1_1quantum_1_1IThreadContext.html#a6488bdb8b5c270ebaa069d7d9ed5819a">Bloomberg::quantum::IThreadContext&lt; RET &gt;</a>.</p>

</div>
</div>
<a id="ac1fecdd49135f75ed831a4bb2c327624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fecdd49135f75ed831a4bb2c327624">&#9670;&nbsp;</a></span>waitForAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future_status <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::waitForAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the future in the 'num-th' continuation context to be ready for a maximum of 'timeMs' milliseconds. </p>
<p>Allowed range for num is [-1, total_continuations). -1 is equivalent of calling <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a084c691c4873a2dd206b05ecd3e5dd34" title="Waits for the future associated with this context to be ready.">wait()</a> or waitAt(total_continuations-1) on the last context in the chain (i.e. the context which is returned via <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html#a671d7fb7fb234086b568a101dde84b0b" title="This is the last method in a continuation chain.">end()</a>). Position 0 represents the first future in the chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The number indicating which future to wait on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to the coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeMs</td><td>The maximum amount of milliseconds to wait until the future value becomes ready. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'ready' if value was posted before duration expired or 'timeout' otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocks until the value is ready, until 'timeMs' duration expires or until an exception is thrown. </dd></dl>

<p>Implements <a class="el" href="../../de/d67/structBloomberg_1_1quantum_1_1ICoroContextBase.html#a15581e24f526c0dfa0b3d3d9bb204a1f">Bloomberg::quantum::ICoroContextBase</a>.</p>

</div>
</div>
<a id="a83acb42a49d715661b7489479a2cbd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83acb42a49d715661b7489479a2cbd53">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Bloomberg::quantum::Context</a>&lt; RET &gt;::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly yields this coroutine context. </p>

<p>Implements <a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a2eca1ca5aa6e819c88a65214289290d4">Bloomberg::quantum::ICoroSync</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a655724ff396688037fb9bef66afc3f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655724ff396688037fb9bef66afc3f4e">&#9670;&nbsp;</a></span>Context</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<div class="memtemplate">
template&lt;class OTHER_RET &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="../../d9/d6d/classclass.html">class</a> <a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad90424f003fc2afb836709cbffa47e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90424f003fc2afb836709cbffa47e2c">&#9670;&nbsp;</a></span>Dispatcher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="../../d9/d6d/classclass.html">class</a> <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html">Dispatcher</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa7728226b6ce66782e8816b1658dd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7728226b6ce66782e8816b1658dd9a">&#9670;&nbsp;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="../../d9/d6d/classclass.html">class</a> <a class="el" href="../../d0/d90/classBloomberg_1_1quantum_1_1Task.html">Task</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99f04ddc152652e7528afd95934466d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f04ddc152652e7528afd95934466d1">&#9670;&nbsp;</a></span>Util</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="../../d1/db1/structBloomberg_1_1quantum_1_1Util.html">Util</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/db9/namespaceBloomberg.html">Bloomberg</a></li><li class="navelem"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="../../d8/df7/classBloomberg_1_1quantum_1_1Context.html">Context</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
