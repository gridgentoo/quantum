<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantumLibrary: Bloomberg::quantum::Dispatcher Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantumLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d9/d29/classBloomberg_1_1quantum_1_1Dispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bloomberg::quantum::Dispatcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main entry point into the library.  
 <a href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d2f/quantum__dispatcher_8h_source.html">quantum_dispatcher.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Bloomberg::quantum::Dispatcher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.png" usemap="#Bloomberg::quantum::Dispatcher_map" alt=""/>
  <map id="Bloomberg::quantum::Dispatcher_map" name="Bloomberg::quantum::Dispatcher_map">
<area href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html" title="Represents an object which can be terminated. This interface allows certain objects to be explicitly ..." alt="Bloomberg::quantum::ITerminate" shape="rect" coords="0,0,191,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa6e5a6cd4905afe2c1d7c9bc620b321e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#aa6e5a6cd4905afe2c1d7c9bc620b321e">ContextTag</a> = <a class="el" href="../../de/de9/structBloomberg_1_1quantum_1_1ThreadContextTag.html">ThreadContextTag</a></td></tr>
<tr class="separator:aa6e5a6cd4905afe2c1d7c9bc620b321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2871b47899d42838de63bbc94f088bbe"><td class="memItemLeft" align="right" valign="top">DEPRECATED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a2871b47899d42838de63bbc94f088bbe">Dispatcher</a> (int numCoroutineThreads=-1, int numIoThreads=5, bool pinCoroutineThreadsToCores=false)</td></tr>
<tr class="memdesc:a2871b47899d42838de63bbc94f088bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2871b47899d42838de63bbc94f088bbe">More...</a><br /></td></tr>
<tr class="separator:a2871b47899d42838de63bbc94f088bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e5dd6f0861296fe1ab56bf1ae5502c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#ad3e5dd6f0861296fe1ab56bf1ae5502c">Dispatcher</a> (const <a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html">Configuration</a> &amp;config)</td></tr>
<tr class="memdesc:ad3e5dd6f0861296fe1ab56bf1ae5502c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. @oaram[in] config The configuration for the Quantum dispatcher.  <a href="#ad3e5dd6f0861296fe1ab56bf1ae5502c">More...</a><br /></td></tr>
<tr class="separator:ad3e5dd6f0861296fe1ab56bf1ae5502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce33c9ae341c9592a0d1c74b5ef30b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a2ce33c9ae341c9592a0d1c74b5ef30b3">~Dispatcher</a> ()</td></tr>
<tr class="memdesc:a2ce33c9ae341c9592a0d1c74b5ef30b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2ce33c9ae341c9592a0d1c74b5ef30b3">More...</a><br /></td></tr>
<tr class="separator:a2ce33c9ae341c9592a0d1c74b5ef30b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c160004cdf4b6c0a18bdaf138b650ac"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a5c160004cdf4b6c0a18bdaf138b650ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac">post</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5c160004cdf4b6c0a18bdaf138b650ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously.  <a href="#a5c160004cdf4b6c0a18bdaf138b650ac">More...</a><br /></td></tr>
<tr class="separator:a5c160004cdf4b6c0a18bdaf138b650ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c66620eed9e3d73226df2761122db8"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a94c66620eed9e3d73226df2761122db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a94c66620eed9e3d73226df2761122db8">post</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a94c66620eed9e3d73226df2761122db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a coroutine to run asynchronously on a specific queue (thread).  <a href="#a94c66620eed9e3d73226df2761122db8">More...</a><br /></td></tr>
<tr class="separator:a94c66620eed9e3d73226df2761122db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea6c5d5a3355cc92a1ac989ba0731e5"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a1ea6c5d5a3355cc92a1ac989ba0731e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a1ea6c5d5a3355cc92a1ac989ba0731e5">postFirst</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1ea6c5d5a3355cc92a1ac989ba0731e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post the first coroutine in a continuation chain to run asynchronously.  <a href="#a1ea6c5d5a3355cc92a1ac989ba0731e5">More...</a><br /></td></tr>
<tr class="separator:a1ea6c5d5a3355cc92a1ac989ba0731e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579c7bcbc28da22e1089be8908b3f204"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a579c7bcbc28da22e1089be8908b3f204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a579c7bcbc28da22e1089be8908b3f204">postFirst</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a579c7bcbc28da22e1089be8908b3f204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post the first coroutine in a continuation chain to run asynchronously on a specific queue (thread).  <a href="#a579c7bcbc28da22e1089be8908b3f204">More...</a><br /></td></tr>
<tr class="separator:a579c7bcbc28da22e1089be8908b3f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ea411ae684451cb800f2ef705095e3"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:a24ea411ae684451cb800f2ef705095e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a742e0d39218b80ae60f30d47ae58bbc9">ThreadFuturePtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a24ea411ae684451cb800f2ef705095e3">postAsyncIo</a> (FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:a24ea411ae684451cb800f2ef705095e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a blocking IO (or long running) task to run asynchronously on the IO thread pool.  <a href="#a24ea411ae684451cb800f2ef705095e3">More...</a><br /></td></tr>
<tr class="separator:a24ea411ae684451cb800f2ef705095e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd36b9153f05b6f89fa35085bdd63917"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class FUNC , class ... ARGS&gt; </td></tr>
<tr class="memitem:abd36b9153f05b6f89fa35085bdd63917"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a742e0d39218b80ae60f30d47ae58bbc9">ThreadFuturePtr</a>&lt; RET &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#abd36b9153f05b6f89fa35085bdd63917">postAsyncIo</a> (int queueId, bool isHighPriority, FUNC &amp;&amp;func, ARGS &amp;&amp;... args)</td></tr>
<tr class="memdesc:abd36b9153f05b6f89fa35085bdd63917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a blocking IO (or long running) task to run asynchronously on a specific thread in the IO thread pool.  <a href="#abd36b9153f05b6f89fa35085bdd63917">More...</a><br /></td></tr>
<tr class="separator:abd36b9153f05b6f89fa35085bdd63917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9281ee1e58963babb99304bc9cf3f16"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:af9281ee1e58963babb99304bc9cf3f16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af9281ee1e58963babb99304bc9cf3f16">forEach</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:af9281ee1e58963babb99304bc9cf3f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the given unary function to all the elements in the range [first,last). This function runs in parallel.  <a href="#af9281ee1e58963babb99304bc9cf3f16">More...</a><br /></td></tr>
<tr class="separator:af9281ee1e58963babb99304bc9cf3f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4289727370da328c6090d455d98c60f"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class INPUT_IT &gt; </td></tr>
<tr class="memitem:ae4289727370da328c6090d455d98c60f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; RET &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#ae4289727370da328c6090d455d98c60f">forEach</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:ae4289727370da328c6090d455d98c60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af9281ee1e58963babb99304bc9cf3f16" title="Applies the given unary function to all the elements in the range [first,last). This function runs in...">forEach()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#ae4289727370da328c6090d455d98c60f">More...</a><br /></td></tr>
<tr class="separator:ae4289727370da328c6090d455d98c60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7606eec66e86bb175f090afd92d4f806"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a7606eec66e86bb175f090afd92d4f806"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; std::vector&lt; RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a7606eec66e86bb175f090afd92d4f806">forEachBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a7606eec66e86bb175f090afd92d4f806"><td class="mdescLeft">&#160;</td><td class="mdescRight">The batched version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af9281ee1e58963babb99304bc9cf3f16" title="Applies the given unary function to all the elements in the range [first,last). This function runs in...">forEach()</a>. This function applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch.  <a href="#a7606eec66e86bb175f090afd92d4f806">More...</a><br /></td></tr>
<tr class="separator:a7606eec66e86bb175f090afd92d4f806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3009907d7f53052633af50204cc94868"><td class="memTemplParams" colspan="2">template&lt;class RET  = int, class INPUT_IT &gt; </td></tr>
<tr class="memitem:a3009907d7f53052633af50204cc94868"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; std::vector&lt; RET &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a3009907d7f53052633af50204cc94868">forEachBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt; func)</td></tr>
<tr class="memdesc:a3009907d7f53052633af50204cc94868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a7606eec66e86bb175f090afd92d4f806" title="The batched version of forEach(). This function applies the given unary function to all the elements ...">forEachBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#a3009907d7f53052633af50204cc94868">More...</a><br /></td></tr>
<tr class="separator:a3009907d7f53052633af50204cc94868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e382dc993e327ec2f27068023390075"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a6e382dc993e327ec2f27068023390075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6e382dc993e327ec2f27068023390075">mapReduce</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a6e382dc993e327ec2f27068023390075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of map-reduce functionality.  <a href="#a6e382dc993e327ec2f27068023390075">More...</a><br /></td></tr>
<tr class="separator:a6e382dc993e327ec2f27068023390075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac693d6b10ecbe1cda8bc022d16e3ee29"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:ac693d6b10ecbe1cda8bc022d16e3ee29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#ac693d6b10ecbe1cda8bc022d16e3ee29">mapReduce</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:ac693d6b10ecbe1cda8bc022d16e3ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6e382dc993e327ec2f27068023390075" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#ac693d6b10ecbe1cda8bc022d16e3ee29">More...</a><br /></td></tr>
<tr class="separator:ac693d6b10ecbe1cda8bc022d16e3ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a528a6d88f8f1bcc2852df50cc05597"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class  = Traits::IsInputIterator&lt;INPUT_IT&gt;&gt; </td></tr>
<tr class="memitem:a6a528a6d88f8f1bcc2852df50cc05597"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6a528a6d88f8f1bcc2852df50cc05597">mapReduceBatch</a> (INPUT_IT first, INPUT_IT last, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:a6a528a6d88f8f1bcc2852df50cc05597"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6e382dc993e327ec2f27068023390075" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO.  <a href="#a6a528a6d88f8f1bcc2852df50cc05597">More...</a><br /></td></tr>
<tr class="separator:a6a528a6d88f8f1bcc2852df50cc05597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa420598b20a9d950bda222a803ec49b2"><td class="memTemplParams" colspan="2">template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </td></tr>
<tr class="memitem:aa420598b20a9d950bda222a803ec49b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#aa420598b20a9d950bda222a803ec49b2">mapReduceBatch</a> (INPUT_IT first, size_t num, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt; mapper, <a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt; reducer)</td></tr>
<tr class="memdesc:aa420598b20a9d950bda222a803ec49b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6a528a6d88f8f1bcc2852df50cc05597" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator.  <a href="#aa420598b20a9d950bda222a803ec49b2">More...</a><br /></td></tr>
<tr class="separator:aa420598b20a9d950bda222a803ec49b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8715f18ec4dc05c89b0062701ef17a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#ab8715f18ec4dc05c89b0062701ef17a6">terminate</a> () final</td></tr>
<tr class="memdesc:ab8715f18ec4dc05c89b0062701ef17a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal all threads to immediately terminate and exit. All other pending coroutines and IO tasks will not complete. Call this function for a fast shutdown of the dispatcher.  <a href="#ab8715f18ec4dc05c89b0062701ef17a6">More...</a><br /></td></tr>
<tr class="separator:ab8715f18ec4dc05c89b0062701ef17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e9603a79d9feafc91a3a764e8a7d1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a841e9603a79d9feafc91a3a764e8a7d1">size</a> (<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a> type=<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a>, int queueId=(int) <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a>) const</td></tr>
<tr class="memdesc:a841e9603a79d9feafc91a3a764e8a7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of queued tasks for the specified type and queue id.  <a href="#a841e9603a79d9feafc91a3a764e8a7d1">More...</a><br /></td></tr>
<tr class="separator:a841e9603a79d9feafc91a3a764e8a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85adfabb7f5d5788de3ef6d8433259f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a85adfabb7f5d5788de3ef6d8433259f3">empty</a> (<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a> type=<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a>, int queueId=(int) <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a>) const</td></tr>
<tr class="memdesc:a85adfabb7f5d5788de3ef6d8433259f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified type and queue id is empty (i.e. there are no running tasks)  <a href="#a85adfabb7f5d5788de3ef6d8433259f3">More...</a><br /></td></tr>
<tr class="separator:a85adfabb7f5d5788de3ef6d8433259f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70d412946a48308687966a3c6089a6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af70d412946a48308687966a3c6089a6d">drain</a> (std::chrono::milliseconds timeout=std::chrono::milliseconds::zero())</td></tr>
<tr class="memdesc:af70d412946a48308687966a3c6089a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drains all queues on this dispatcher object.  <a href="#af70d412946a48308687966a3c6089a6d">More...</a><br /></td></tr>
<tr class="separator:af70d412946a48308687966a3c6089a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be91ea87c7095558a2e678e750b467d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a2be91ea87c7095558a2e678e750b467d">getNumCoroutineThreads</a> () const</td></tr>
<tr class="memdesc:a2be91ea87c7095558a2e678e750b467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying coroutine threads as specified in the constructor. If -1 was passed than this number essentially indicates the number of cores.  <a href="#a2be91ea87c7095558a2e678e750b467d">More...</a><br /></td></tr>
<tr class="separator:a2be91ea87c7095558a2e678e750b467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fee5233633dcf411120ce0d9bbe683f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a0fee5233633dcf411120ce0d9bbe683f">getNumIoThreads</a> () const</td></tr>
<tr class="memdesc:a0fee5233633dcf411120ce0d9bbe683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of underlying IO threads as specified in the constructor.  <a href="#a0fee5233633dcf411120ce0d9bbe683f">More...</a><br /></td></tr>
<tr class="separator:a0fee5233633dcf411120ce0d9bbe683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f75cbfc894f962fcf6ff946154ece0c"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; int, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a3f75cbfc894f962fcf6ff946154ece0c">getCoroQueueIdRangeForAny</a> () const</td></tr>
<tr class="memdesc:a3f75cbfc894f962fcf6ff946154ece0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> when using <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a>.  <a href="#a3f75cbfc894f962fcf6ff946154ece0c">More...</a><br /></td></tr>
<tr class="separator:a3f75cbfc894f962fcf6ff946154ece0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2948d83722bec051e4547848bfcf0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d7b/classBloomberg_1_1quantum_1_1QueueStatistics.html">QueueStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#afe2948d83722bec051e4547848bfcf0e">stats</a> (<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a> type=<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a>, int queueId=(int) <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a>)</td></tr>
<tr class="memdesc:afe2948d83722bec051e4547848bfcf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a statistics object for the specified type and queue id.  <a href="#afe2948d83722bec051e4547848bfcf0e">More...</a><br /></td></tr>
<tr class="separator:afe2948d83722bec051e4547848bfcf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d990ec39694d86dd8f5df1f5c50d65c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5d990ec39694d86dd8f5df1f5c50d65c">resetStats</a> ()</td></tr>
<tr class="memdesc:a5d990ec39694d86dd8f5df1f5c50d65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all coroutine and IO queue counters.  <a href="#a5d990ec39694d86dd8f5df1f5c50d65c">More...</a><br /></td></tr>
<tr class="separator:a5d990ec39694d86dd8f5df1f5c50d65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structBloomberg_1_1quantum_1_1ITerminate')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html">Bloomberg::quantum::ITerminate</a></td></tr>
<tr class="memitem:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a4086a8ce16fc2482ee77701d387b14d8">~ITerminate</a> ()=default</td></tr>
<tr class="memdesc:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. This function is explicitly left empty.  <a href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a4086a8ce16fc2482ee77701d387b14d8">More...</a><br /></td></tr>
<tr class="separator:a4086a8ce16fc2482ee77701d387b14d8 inherit pub_methods_structBloomberg_1_1quantum_1_1ITerminate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parallel execution engine used to run coroutines or IO tasks asynchronously. This class is the main entry point into the library. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa6e5a6cd4905afe2c1d7c9bc620b321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5a6cd4905afe2c1d7c9bc620b321e">&#9670;&nbsp;</a></span>ContextTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#aa6e5a6cd4905afe2c1d7c9bc620b321e">Bloomberg::quantum::Dispatcher::ContextTag</a> =  <a class="el" href="../../de/de9/structBloomberg_1_1quantum_1_1ThreadContextTag.html">ThreadContextTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2871b47899d42838de63bbc94f088bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2871b47899d42838de63bbc94f088bbe">&#9670;&nbsp;</a></span>Dispatcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::Dispatcher::Dispatcher </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numCoroutineThreads</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numIoThreads</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinCoroutineThreadsToCores</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This will build two thread pools, one used for running parallel coroutines and another used for running blocking IO tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numCoroutineThreads</td><td>Number of parallel threads running coroutines. -1 indicates one per core. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numIoThreads</td><td>Number of parallel threads running blocking IO calls. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pinCoroutineThreadsToCores</td><td>If set to true, it will pin all coroutine threads unto physical cores. provided numCoroutineThreads &lt;= cores. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This constructor is deprecated and will be removed in v1.0. Use the configuration-based constructor instead. </dd></dl>

</div>
</div>
<a id="ad3e5dd6f0861296fe1ab56bf1ae5502c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e5dd6f0861296fe1ab56bf1ae5502c">&#9670;&nbsp;</a></span>Dispatcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::Dispatcher::Dispatcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/dda/classBloomberg_1_1quantum_1_1Configuration.html">Configuration</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. @oaram[in] config The configuration for the Quantum dispatcher. </p>

</div>
</div>
<a id="a2ce33c9ae341c9592a0d1c74b5ef30b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce33c9ae341c9592a0d1c74b5ef30b3">&#9670;&nbsp;</a></span>~Dispatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::Dispatcher::~Dispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Destroys the task dispatcher object. This will wait until all coroutines complete, signal all worker threads (coroutine and IO) to exit and join them. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af70d412946a48308687966a3c6089a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70d412946a48308687966a3c6089a6d">&#9670;&nbsp;</a></span>drain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::Dispatcher::drain </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds::zero()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drains all queues on this dispatcher object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Maximum time for this function to wait. Set to 0 to wait indefinitely until all queues drain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function blocks until all coroutines and IO tasks have completed. During this time, posting of new tasks is disabled unless they are posted from within an already executing coroutine. </dd></dl>

</div>
</div>
<a id="a85adfabb7f5d5788de3ef6d8433259f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85adfabb7f5d5788de3ef6d8433259f3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Bloomberg::quantum::Dispatcher::empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em> = <code>(int)<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the specified type and queue id is empty (i.e. there are no running tasks) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>The queue number to query. Valid range is [0, numCoroutineThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbad594f8e0e058efd6cc21aa4ec8498277">IQueue::QueueType::Coro</a>, [0, numIoThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbacf3882f1c43ab22bff0bd9d82d83251b">IQueue::QueueType::IO</a> and <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a> for either. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> is an invalid queue id. <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is only valid for IO queue type. When type <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a> is specified, the queueId is not used and must be left at default value. </dd></dl>

</div>
</div>
<a id="af9281ee1e58963babb99304bc9cf3f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9281ee1e58963babb99304bc9cf3f16">&#9670;&nbsp;</a></span>forEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; RET &gt; &gt; Bloomberg::quantum::Dispatcher::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the given unary function to all the elements in the range [first,last). This function runs in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>The return value of the unary function. </td></tr>
    <tr><td class="paramname">UNARY_FUNC</td><td>A unary function of type 'RET(*INPUT_IT)'. </td></tr>
    <tr><td class="paramname">InputIt</td><td>The type of iterator. @oaram[in] first The first element in the range. @oaram[in] last The last element in the range (exclusive). @oaram[in] func The unary function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of future values corresponding to the output of 'func' on every element in the range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator </dd>
<dd>
Each func invocation will run inside its own coroutine instance. </dd></dl>

</div>
</div>
<a id="ae4289727370da328c6090d455d98c60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4289727370da328c6090d455d98c60f">&#9670;&nbsp;</a></span>forEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; RET &gt; &gt; Bloomberg::quantum::Dispatcher::forEach </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af9281ee1e58963babb99304bc9cf3f16" title="Applies the given unary function to all the elements in the range [first,last). This function runs in...">forEach()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

</div>
</div>
<a id="a7606eec66e86bb175f090afd92d4f806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7606eec66e86bb175f090afd92d4f806">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; std::vector&lt; RET &gt; &gt; &gt; Bloomberg::quantum::Dispatcher::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The batched version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#af9281ee1e58963babb99304bc9cf3f16" title="Applies the given unary function to all the elements in the range [first,last). This function runs in...">forEach()</a>. This function applies the given unary function to all the elements in the range [first,last). This function runs serially with respect to other functions in the same batch. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of value vectors (i.e. one per batch). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd>
<dd>
The input range is split equally among coroutines and executed in batches. This function achieves higher throughput rates than the non-batched mode, if func() is CPU-bound. </dd></dl>

</div>
</div>
<a id="a3009907d7f53052633af50204cc94868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3009907d7f53052633af50204cc94868">&#9670;&nbsp;</a></span>forEachBatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::vector&lt; std::vector&lt; RET &gt; &gt; &gt; Bloomberg::quantum::Dispatcher::forEachBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a510a24630512ab725361c0250bbf882e">Functions::ForEachFunc</a>&lt; RET, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a7606eec66e86bb175f090afd92d4f806" title="The batched version of forEach(). This function applies the given unary function to all the elements ...">forEachBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

</div>
</div>
<a id="a3f75cbfc894f962fcf6ff946154ece0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f75cbfc894f962fcf6ff946154ece0c">&#9670;&nbsp;</a></span>getCoroQueueIdRangeForAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; int, int &gt; &amp; Bloomberg::quantum::Dispatcher::getCoroQueueIdRangeForAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the range [minQueueId, maxQueueId] of coroutine queueIds covered by <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> when using <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">Dispatcher::post</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>queueIdRange The range of queueIds that <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> covers </dd></dl>

</div>
</div>
<a id="a2be91ea87c7095558a2e678e750b467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be91ea87c7095558a2e678e750b467d">&#9670;&nbsp;</a></span>getNumCoroutineThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bloomberg::quantum::Dispatcher::getNumCoroutineThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of underlying coroutine threads as specified in the constructor. If -1 was passed than this number essentially indicates the number of cores. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning coroutines to a specific queue. </dd></dl>

</div>
</div>
<a id="a0fee5233633dcf411120ce0d9bbe683f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fee5233633dcf411120ce0d9bbe683f">&#9670;&nbsp;</a></span>getNumIoThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Bloomberg::quantum::Dispatcher::getNumIoThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of underlying IO threads as specified in the constructor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Each thread services its own queueId, therefore this number can be used when assigning IO tasks to a specific queue. </dd></dl>

</div>
</div>
<a id="a6e382dc993e327ec2f27068023390075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e382dc993e327ec2f27068023390075">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt; Bloomberg::quantum::Dispatcher::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of map-reduce functionality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KEY</td><td>The KEY type used for mapping and reducing. </td></tr>
    <tr><td class="paramname">MAPPED_TYPE</td><td>The output type after a map operation. </td></tr>
    <tr><td class="paramname">REDUCED_TYPE</td><td>The output type after a reduce operation. </td></tr>
    <tr><td class="paramname">MAPPER_FUNC</td><td>The mapper function having the signature 'std::vector&lt;std::pair&lt;KEY,MAPPED_TYPE&gt;&gt;(*INPUT_IT)' </td></tr>
    <tr><td class="paramname">REDUCER_FUNC</td><td>The reducer function having the signature 'std::pair&lt;KEY,REDUCED_TYPE&gt;(std::pair&lt;KEY, std::vector&lt;MAPPED_TYPE&gt;&gt;&amp;&amp;)' </td></tr>
    <tr><td class="paramname">INPUT_IT</td><td>The iterator type. @oaram[in] first The start iterator to a list of items to be processed in the range [first,last). @oaram[in] last The end iterator to a list of items (not inclusive). @oaram[in] mapper The mapper function. @oaram[in] reducer The reducer function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to a reduced map of values. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

</div>
</div>
<a id="ac693d6b10ecbe1cda8bc022d16e3ee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac693d6b10ecbe1cda8bc022d16e3ee29">&#9670;&nbsp;</a></span>mapReduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt; Bloomberg::quantum::Dispatcher::mapReduce </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6e382dc993e327ec2f27068023390075" title="Implementation of map-reduce functionality.">mapReduce()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

</div>
</div>
<a id="a6a528a6d88f8f1bcc2852df50cc05597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a528a6d88f8f1bcc2852df50cc05597">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt; Bloomberg::quantum::Dispatcher::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6e382dc993e327ec2f27068023390075" title="Implementation of map-reduce functionality.">mapReduce()</a> runs both the mapper and the reducer functions in batches for improved performance. This should be used in the case where the functions are more CPU intensive with little or no IO. </p>
<dl class="section note"><dt>Note</dt><dd>Use this function if InputIt meets the requirement of a RandomAccessIterator. </dd></dl>

</div>
</div>
<a id="aa420598b20a9d950bda222a803ec49b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa420598b20a9d950bda222a803ec49b2">&#9670;&nbsp;</a></span>mapReduceBatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class MAPPED_TYPE , class REDUCED_TYPE , class INPUT_IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; std::map&lt; KEY, REDUCED_TYPE &gt; &gt; Bloomberg::quantum::Dispatcher::mapReduceBatch </td>
          <td>(</td>
          <td class="paramtype">INPUT_IT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#af8fdee23da6d53ce304c908981315528">Functions::MapFunc</a>&lt; KEY, MAPPED_TYPE, INPUT_IT &gt;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d25/structBloomberg_1_1quantum_1_1Functions.html#a4f8eb1de73c9ec3661fee4242f1a2a87">Functions::ReduceFunc</a>&lt; KEY, MAPPED_TYPE, REDUCED_TYPE &gt;&#160;</td>
          <td class="paramname"><em>reducer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a6a528a6d88f8f1bcc2852df50cc05597" title="This version of mapReduce() runs both the mapper and the reducer functions in batches for improved pe...">mapReduceBatch()</a> but takes a length as second argument in case INPUT_IT is not a random access iterator. </p>

</div>
</div>
<a id="a5c160004cdf4b6c0a18bdaf138b650ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c160004cdf4b6c0a18bdaf138b650ac">&#9670;&nbsp;</a></span>post() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::post </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously. </p>
<p>This method will post the coroutine on any thread available. Typically it will pick one which has the smallest number of concurrent coroutines executing at the time of the post. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned thread context cannot be used to chain further coroutines. </dd></dl>

</div>
</div>
<a id="a94c66620eed9e3d73226df2761122db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c66620eed9e3d73226df2761122db8">&#9670;&nbsp;</a></span>post() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a coroutine to run asynchronously on a specific queue (thread). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned thread context cannot be used to chain further coroutines. </dd></dl>

</div>
</div>
<a id="a24ea411ae684451cb800f2ef705095e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ea411ae684451cb800f2ef705095e3">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a742e0d39218b80ae60f30d47ae58bbc9">ThreadFuturePtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a blocking IO (or long running) task to run asynchronously on the IO thread pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this task. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread future object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The passed function will not be wrapped in a coroutine. </dd></dl>

</div>
</div>
<a id="abd36b9153f05b6f89fa35085bdd63917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd36b9153f05b6f89fa35085bdd63917">&#9670;&nbsp;</a></span>postAsyncIo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#a742e0d39218b80ae60f30d47ae58bbc9">ThreadFuturePtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::postAsyncIo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a blocking IO (or long running) task to run asynchronously on a specific thread in the IO thread pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this task. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(ThreadPromise&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this task should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a24ea411ae684451cb800f2ef705095e3" title="Post a blocking IO (or long running) task to run asynchronously on the IO thread pool.">postAsyncIo()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the task will be scheduled to run immediately. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread future object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The passed function will not be wrapped in a coroutine. </dd></dl>

</div>
</div>
<a id="a1ea6c5d5a3355cc92a1ac989ba0731e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea6c5d5a3355cc92a1ac989ba0731e5">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::postFirst </td>
          <td>(</td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post the first coroutine in a continuation chain to run asynchronously. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain other coroutines which will run sequentially. </dd></dl>

</div>
</div>
<a id="a579c7bcbc28da22e1089be8908b3f204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579c7bcbc28da22e1089be8908b3f204">&#9670;&nbsp;</a></span>postFirst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RET , class FUNC , class ... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html#aa26dcdfb6c3930c1cd2b4000d8711f4c">ThreadContextPtr</a>&lt; RET &gt; Bloomberg::quantum::Dispatcher::postFirst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isHighPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNC &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post the first coroutine in a continuation chain to run asynchronously on a specific queue (thread). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RET</td><td>Type of future returned by this coroutine. </td></tr>
    <tr><td class="paramname">FUNC</td><td>Callable object type which will be wrapped in a coroutine. Can be a standalone function, a method, an std::function, a functor generated via std::bind or a lambda. The signature of the callable object must strictly be 'int f(CoroContext&lt;RET&gt;::Ptr, ...)'. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types passed to FUNC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>Id of the queue where this coroutine should run. Note that the user can specify <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> as a value, which is equivalent to running the simpler version of <a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html#a5c160004cdf4b6c0a18bdaf138b650ac" title="Post a coroutine to run asynchronously.">post()</a> above. Valid range is [0, numCoroutineThreads) or <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHighPriority</td><td>If set to true, the coroutine will be scheduled to run immediately after the currently executing coroutine on 'queueId' has completed or has yielded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Callable object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable list of arguments passed to the callable object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a thread context object. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is non-blocking and returns immediately. The returned context can be used to chain other coroutines which will run sequentially. </dd></dl>

</div>
</div>
<a id="a5d990ec39694d86dd8f5df1f5c50d65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d990ec39694d86dd8f5df1f5c50d65c">&#9670;&nbsp;</a></span>resetStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::Dispatcher::resetStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all coroutine and IO queue counters. </p>

</div>
</div>
<a id="a841e9603a79d9feafc91a3a764e8a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841e9603a79d9feafc91a3a764e8a7d1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Bloomberg::quantum::Dispatcher::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em> = <code>(int)<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of queued tasks for the specified type and queue id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>The queue number to query. Valid range is [0, numCoroutineThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbad594f8e0e058efd6cc21aa4ec8498277">IQueue::QueueType::Coro</a>, [0, numIoThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbacf3882f1c43ab22bff0bd9d82d83251b">IQueue::QueueType::IO</a> and <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a> for either. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of queued tasks including the currently executing one. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> is an invalid queue id. <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is only valid for IO queue type. When type <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a> is specified, the queueId is not used and must be left at default value. </dd></dl>

</div>
</div>
<a id="afe2948d83722bec051e4547848bfcf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2948d83722bec051e4547848bfcf0e">&#9670;&nbsp;</a></span>stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d7b/classBloomberg_1_1quantum_1_1QueueStatistics.html">QueueStatistics</a> Bloomberg::quantum::Dispatcher::stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facb">IQueue::QueueType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em> = <code>(int)<a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a statistics object for the specified type and queue id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of queue. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queueId</td><td>The queue number to query. Valid range is [0, numCoroutineThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbad594f8e0e058efd6cc21aa4ec8498277">IQueue::QueueType::Coro</a>, [0, numIoThreads) for <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbacf3882f1c43ab22bff0bd9d82d83251b">IQueue::QueueType::IO</a> and <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueId::All</a> for either. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aggregated or individual queue stats. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eac90a13d8ec8fe53c6bb33fe10af6f2fe">IQueue::QueueId::Same</a> is an invalid queue id. <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#aec9f17dc0836162032f0239b2415649eaed36a1ef76a59ee3f15180e0441188ad">IQueue::QueueId::Any</a> is only valid for IO queue type. When type <a class="el" href="../../d2/db0/structBloomberg_1_1quantum_1_1IQueue.html#a5d3e6340ac9844b3fabb6759e1b7facbab1c94ca2fbc3e78fc30069c8d0f01680">IQueue::QueueType::All</a> is specified, the queueId is not used and must be left at default value. </dd></dl>

</div>
</div>
<a id="ab8715f18ec4dc05c89b0062701ef17a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8715f18ec4dc05c89b0062701ef17a6">&#9670;&nbsp;</a></span>terminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::Dispatcher::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal all threads to immediately terminate and exit. All other pending coroutines and IO tasks will not complete. Call this function for a fast shutdown of the dispatcher. </p>
<dl class="section note"><dt>Note</dt><dd>This function blocks. </dd></dl>

<p>Implements <a class="el" href="../../d9/ddb/structBloomberg_1_1quantum_1_1ITerminate.html#a66e42ce854b5afbb7742c5ffdaae8503">Bloomberg::quantum::ITerminate</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/db9/namespaceBloomberg.html">Bloomberg</a></li><li class="navelem"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="../../d0/da5/classBloomberg_1_1quantum_1_1Dispatcher.html">Dispatcher</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
