<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuantumLibrary: Bloomberg::quantum::ConditionVariable Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuantumLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d8/d8d/classBloomberg_1_1quantum_1_1ConditionVariable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Bloomberg::quantum::ConditionVariable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a coroutine-compatible implementation of the std::condition_variable. Most methods of the latter have been recreated with the same behavior. This object will yield instead of blocking if called from a coroutine.  
 <a href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../db/dfa/quantum__condition__variable_8h_source.html">quantum_condition_variable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4bab37cb921df0f105899bb3eae1cc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#ad4bab37cb921df0f105899bb3eae1cc9">ConditionVariable</a> ()</td></tr>
<tr class="memdesc:ad4bab37cb921df0f105899bb3eae1cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad4bab37cb921df0f105899bb3eae1cc9">More...</a><br /></td></tr>
<tr class="separator:ad4bab37cb921df0f105899bb3eae1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c3515723eba2338c21a591150cf4da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a21c3515723eba2338c21a591150cf4da">ConditionVariable</a> (const <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;other)=delete</td></tr>
<tr class="separator:a21c3515723eba2338c21a591150cf4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aff50540eeb49818b749cb09ed40b92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a2aff50540eeb49818b749cb09ed40b92">ConditionVariable</a> (<a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a2aff50540eeb49818b749cb09ed40b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b28ea05695465a8d78c64db5c872f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a060b28ea05695465a8d78c64db5c872f">operator=</a> (const <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;other)=delete</td></tr>
<tr class="separator:a060b28ea05695465a8d78c64db5c872f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7176b5668c146e4e6fe9e48ae1a2d8b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a7176b5668c146e4e6fe9e48ae1a2d8b7">operator=</a> (<a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:a7176b5668c146e4e6fe9e48ae1a2d8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08203af67a4ce39ca5e1e6769708a38b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a08203af67a4ce39ca5e1e6769708a38b">~ConditionVariable</a> ()</td></tr>
<tr class="memdesc:a08203af67a4ce39ca5e1e6769708a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a08203af67a4ce39ca5e1e6769708a38b">More...</a><br /></td></tr>
<tr class="separator:a08203af67a4ce39ca5e1e6769708a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f859966efc3dfe0afad40e4fb835136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136">notifyOne</a> ()</td></tr>
<tr class="memdesc:a0f859966efc3dfe0afad40e4fb835136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify one waiting thread or coroutine.  <a href="#a0f859966efc3dfe0afad40e4fb835136">More...</a><br /></td></tr>
<tr class="separator:a0f859966efc3dfe0afad40e4fb835136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cd00d3eda2a7de34c60171997a5b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b">notifyAll</a> ()</td></tr>
<tr class="memdesc:a05cd00d3eda2a7de34c60171997a5b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all waiting threads and coroutines.  <a href="#a05cd00d3eda2a7de34c60171997a5b9b">More...</a><br /></td></tr>
<tr class="separator:a05cd00d3eda2a7de34c60171997a5b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7b890f30ad7a1be940d25b694b02d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2">wait</a> (<a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex)</td></tr>
<tr class="memdesc:abe7b890f30ad7a1be940d25b694b02d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>.  <a href="#abe7b890f30ad7a1be940d25b694b02d2">More...</a><br /></td></tr>
<tr class="separator:abe7b890f30ad7a1be940d25b694b02d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de4ad4bcb968534a62113f1665ace7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a7de4ad4bcb968534a62113f1665ace7d">wait</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, <a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex)</td></tr>
<tr class="memdesc:a7de4ad4bcb968534a62113f1665ace7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current coroutine until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>.  <a href="#a7de4ad4bcb968534a62113f1665ace7d">More...</a><br /></td></tr>
<tr class="separator:a7de4ad4bcb968534a62113f1665ace7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2546689d28052412078ccbcb8bbb19d3"><td class="memTemplParams" colspan="2">template&lt;class PREDICATE  = bool()&gt; </td></tr>
<tr class="memitem:a2546689d28052412078ccbcb8bbb19d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a2546689d28052412078ccbcb8bbb19d3">wait</a> (<a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, PREDICATE predicate)</td></tr>
<tr class="memdesc:a2546689d28052412078ccbcb8bbb19d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>.  <a href="#a2546689d28052412078ccbcb8bbb19d3">More...</a><br /></td></tr>
<tr class="separator:a2546689d28052412078ccbcb8bbb19d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783dc16b839258c68e4201dec3a878c0"><td class="memTemplParams" colspan="2">template&lt;class PREDICATE  = bool()&gt; </td></tr>
<tr class="memitem:a783dc16b839258c68e4201dec3a878c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a783dc16b839258c68e4201dec3a878c0">wait</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, <a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, PREDICATE predicate)</td></tr>
<tr class="memdesc:a783dc16b839258c68e4201dec3a878c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield the current coroutine until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>. When this function returns, the mutex is guaranteed to be locked.  <a href="#a783dc16b839258c68e4201dec3a878c0">More...</a><br /></td></tr>
<tr class="separator:a783dc16b839258c68e4201dec3a878c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb866ea4801a40238fbb83341a37ec7"><td class="memTemplParams" colspan="2">template&lt;class REP , class PERIOD &gt; </td></tr>
<tr class="memitem:aacb866ea4801a40238fbb83341a37ec7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#aacb866ea4801a40238fbb83341a37ec7">waitFor</a> (<a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, const std::chrono::duration&lt; REP, PERIOD &gt; &amp;time)</td></tr>
<tr class="memdesc:aacb866ea4801a40238fbb83341a37ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires.  <a href="#aacb866ea4801a40238fbb83341a37ec7">More...</a><br /></td></tr>
<tr class="separator:aacb866ea4801a40238fbb83341a37ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b32b0515b2892e1c9d40adffd475dd1"><td class="memTemplParams" colspan="2">template&lt;class REP , class PERIOD &gt; </td></tr>
<tr class="memitem:a4b32b0515b2892e1c9d40adffd475dd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a4b32b0515b2892e1c9d40adffd475dd1">waitFor</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, <a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, const std::chrono::duration&lt; REP, PERIOD &gt; &amp;time)</td></tr>
<tr class="memdesc:a4b32b0515b2892e1c9d40adffd475dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires.  <a href="#a4b32b0515b2892e1c9d40adffd475dd1">More...</a><br /></td></tr>
<tr class="separator:a4b32b0515b2892e1c9d40adffd475dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5569866c59a52f73643c07ccd8d37a1b"><td class="memTemplParams" colspan="2">template&lt;class REP , class PERIOD , class PREDICATE  = bool()&gt; </td></tr>
<tr class="memitem:a5569866c59a52f73643c07ccd8d37a1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a5569866c59a52f73643c07ccd8d37a1b">waitFor</a> (<a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, const std::chrono::duration&lt; REP, PERIOD &gt; &amp;time, PREDICATE predicate)</td></tr>
<tr class="memdesc:a5569866c59a52f73643c07ccd8d37a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires.  <a href="#a5569866c59a52f73643c07ccd8d37a1b">More...</a><br /></td></tr>
<tr class="separator:a5569866c59a52f73643c07ccd8d37a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33398e69fa1f6e6e8a7bd4a802abc21"><td class="memTemplParams" colspan="2">template&lt;class REP , class PERIOD , class PREDICATE  = bool()&gt; </td></tr>
<tr class="memitem:aa33398e69fa1f6e6e8a7bd4a802abc21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#aa33398e69fa1f6e6e8a7bd4a802abc21">waitFor</a> (<a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a> sync, <a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;mutex, const std::chrono::duration&lt; REP, PERIOD &gt; &amp;time, PREDICATE predicate)</td></tr>
<tr class="memdesc:aa33398e69fa1f6e6e8a7bd4a802abc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires.  <a href="#aa33398e69fa1f6e6e8a7bd4a802abc21">More...</a><br /></td></tr>
<tr class="separator:aa33398e69fa1f6e6e8a7bd4a802abc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a coroutine-compatible implementation of the std::condition_variable. Most methods of the latter have been recreated with the same behavior. This object will yield instead of blocking if called from a coroutine. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4bab37cb921df0f105899bb3eae1cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bab37cb921df0f105899bb3eae1cc9">&#9670;&nbsp;</a></span>ConditionVariable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::ConditionVariable::ConditionVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a21c3515723eba2338c21a591150cf4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c3515723eba2338c21a591150cf4da">&#9670;&nbsp;</a></span>ConditionVariable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::ConditionVariable::ConditionVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Copy constructor is explicitly deleted. </dd></dl>

</div>
</div>
<a id="a2aff50540eeb49818b749cb09ed40b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aff50540eeb49818b749cb09ed40b92">&#9670;&nbsp;</a></span>ConditionVariable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::ConditionVariable::ConditionVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Move constructor is explicitly deleted. </dd></dl>

</div>
</div>
<a id="a08203af67a4ce39ca5e1e6769708a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08203af67a4ce39ca5e1e6769708a38b">&#9670;&nbsp;</a></span>~ConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bloomberg::quantum::ConditionVariable::~ConditionVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="section warning"><dt>Warning</dt><dd>Deleting this object while there are still waiting threads results in undefined behavior. Ensure that all threads have been notified before doing so. Once the destructor is called, no other wait attempts should be made on this object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a05cd00d3eda2a7de34c60171997a5b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cd00d3eda2a7de34c60171997a5b9b">&#9670;&nbsp;</a></span>notifyAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::notifyAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify all waiting threads and coroutines. </p>

</div>
</div>
<a id="a0f859966efc3dfe0afad40e4fb835136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f859966efc3dfe0afad40e4fb835136">&#9670;&nbsp;</a></span>notifyOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::notifyOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify one waiting thread or coroutine. </p>

</div>
</div>
<a id="a060b28ea05695465a8d78c64db5c872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060b28ea05695465a8d78c64db5c872f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a>&amp; Bloomberg::quantum::ConditionVariable::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Assignment operator is explicitly deleted. </dd></dl>

</div>
</div>
<a id="a7176b5668c146e4e6fe9e48ae1a2d8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7176b5668c146e4e6fe9e48ae1a2d8b7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a>&amp; Bloomberg::quantum::ConditionVariable::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Move assignment operator is explicitly deleted. </dd></dl>

</div>
</div>
<a id="abe7b890f30ad7a1be940d25b694b02d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7b890f30ad7a1be940d25b694b02d2">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>. </p>
<p>When this function returns, the mutex is guaranteed to be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a regular thread not from a coroutine. </dd></dl>

</div>
</div>
<a id="a7de4ad4bcb968534a62113f1665ace7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de4ad4bcb968534a62113f1665ace7d">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yield the current coroutine until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>. </p>
<p>When this function returns, the mutex is guaranteed to be locked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to a coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a coroutine. </dd></dl>

</div>
</div>
<a id="a2546689d28052412078ccbcb8bbb19d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2546689d28052412078ccbcb8bbb19d3">&#9670;&nbsp;</a></span>wait() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PREDICATE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>. </p>
<p>When this function returns, the mutex is guaranteed to be locked. This function calls <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2" title="Block the current thread until the condition is signalled via notifyOne() or notifyAll().">wait()</a> in a loop until the predicate returns true. This ensures that the condition has not changed after <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> have been called. The internal logic is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span>(!predicate())</div><div class="line">{</div><div class="line">    <a class="code" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2">wait</a>(mutex);</div><div class="line">}</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PREDICATE</td><td>Callable function type having the following signature 'bool f()'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td><a class="el" href="../../d7/d56/classBloomberg_1_1quantum_1_1Function.html" title="Similar implementation to std::function except that it allows capture of non-copyable types.">Function</a> or functor to be tested as exit condition of the endless while loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a regular thread not from a coroutine. </dd></dl>

</div>
</div>
<a id="a783dc16b839258c68e4201dec3a878c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783dc16b839258c68e4201dec3a878c0">&#9670;&nbsp;</a></span>wait() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PREDICATE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Bloomberg::quantum::ConditionVariable::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield the current coroutine until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a>. When this function returns, the mutex is guaranteed to be locked. </p>
<p>When this function returns, the mutex is guaranteed to be locked. This function calls <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2" title="Block the current thread until the condition is signalled via notifyOne() or notifyAll().">wait()</a> in a loop until the predicate returns true. This ensures that the condition has not changed after <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> have been called. The internal logic is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span>(!predicate())</div><div class="line">{</div><div class="line">    <a class="code" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2">wait</a>(mutex);</div><div class="line">}</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PREDICATE</td><td>Callable function type having the following signature 'bool f()'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to a coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td><a class="el" href="../../d7/d56/classBloomberg_1_1quantum_1_1Function.html" title="Similar implementation to std::function except that it allows capture of non-copyable types.">Function</a> or functor to be tested as exit condition of the endless while loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a coroutine. </dd></dl>

</div>
</div>
<a id="aacb866ea4801a40238fbb83341a37ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb866ea4801a40238fbb83341a37ec7">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class REP , class PERIOD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Bloomberg::quantum::ConditionVariable::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; REP, PERIOD &gt; &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires. </p>
<p>When this function returns, the mutex is guaranteed to be locked. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REP</td><td>An arithmetic type such as int or double representing the number of ticks. </td></tr>
    <tr><td class="paramname">PERIOD</td><td>A std::ratio representing the tick period such as ticks per second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Maximum duration for which to wait on this condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mutex was acquired before 'time' expired or false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a regular thread not from a coroutine. </dd></dl>

</div>
</div>
<a id="a4b32b0515b2892e1c9d40adffd475dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b32b0515b2892e1c9d40adffd475dd1">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class REP , class PERIOD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Bloomberg::quantum::ConditionVariable::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; REP, PERIOD &gt; &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires. </p>
<p>When this function returns, the mutex is guaranteed to be locked. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REP</td><td>An arithmetic type such as int or double representing the number of ticks. </td></tr>
    <tr><td class="paramname">PERIOD</td><td>A std::ratio representing the tick period such as ticks per second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to a coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Maximum duration for which to wait on this condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mutex was acquired before 'time' expired or false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a coroutine. </dd></dl>

</div>
</div>
<a id="a5569866c59a52f73643c07ccd8d37a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5569866c59a52f73643c07ccd8d37a1b">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class REP , class PERIOD , class PREDICATE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Bloomberg::quantum::ConditionVariable::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; REP, PERIOD &gt; &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires. </p>
<p>When this function returns, the mutex is guaranteed to be locked. This function calls <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2" title="Block the current thread until the condition is signalled via notifyOne() or notifyAll().">wait()</a> in a loop until the predicate returns true or 'time' expires. This ensures that the condition has not changed after <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> have been called. The internal logic is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span>(!predicate())</div><div class="line">{</div><div class="line">    <a class="code" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#aacb866ea4801a40238fbb83341a37ec7">waitFor</a>(mutex, time);</div><div class="line">}</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REP</td><td>An arithmetic type such as int or double representing the number of ticks. </td></tr>
    <tr><td class="paramname">PERIOD</td><td>A std::ratio representing the tick period such as ticks per second. </td></tr>
    <tr><td class="paramname">PREDICATE</td><td>Callable function type having the following signature 'bool f()'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Maximum duration for which to wait on this condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td><a class="el" href="../../d7/d56/classBloomberg_1_1quantum_1_1Function.html" title="Similar implementation to std::function except that it allows capture of non-copyable types.">Function</a> or functor to be tested as exit condition of the endless while loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mutex was acquired before 'time' expired, otherwise the predicate result after timeout. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a regular thread not from a coroutine. </dd></dl>

</div>
</div>
<a id="aa33398e69fa1f6e6e8a7bd4a802abc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33398e69fa1f6e6e8a7bd4a802abc21">&#9670;&nbsp;</a></span>waitFor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class REP , class PERIOD , class PREDICATE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Bloomberg::quantum::ConditionVariable::waitFor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/structBloomberg_1_1quantum_1_1ICoroSync.html#a109b2c4b7d70d53d48bb640a9d849b29">ICoroSync::Ptr</a>&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; REP, PERIOD &gt; &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PREDICATE&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block the current thread until the condition is signalled via <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> or until 'time' duration expires. </p>
<p>When this function returns, the mutex is guaranteed to be locked. This function calls <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#abe7b890f30ad7a1be940d25b694b02d2" title="Block the current thread until the condition is signalled via notifyOne() or notifyAll().">wait()</a> in a loop until the predicate returns true or 'time' expires. This ensures that the condition has not changed after <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a0f859966efc3dfe0afad40e4fb835136" title="Notify one waiting thread or coroutine.">notifyOne()</a> or <a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#a05cd00d3eda2a7de34c60171997a5b9b" title="Notify all waiting threads and coroutines.">notifyAll()</a> have been called. The internal logic is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span>(!predicate())</div><div class="line">{</div><div class="line">    <a class="code" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html#aacb866ea4801a40238fbb83341a37ec7">waitFor</a>(mutex, time);</div><div class="line">}</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REP</td><td>An arithmetic type such as int or double representing the number of ticks. </td></tr>
    <tr><td class="paramname">PERIOD</td><td>A std::ratio representing the tick period such as ticks per second. </td></tr>
    <tr><td class="paramname">PREDICATE</td><td>Callable function type having the following signature 'bool f()'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>Pointer to a coroutine synchronization object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td><a class="el" href="../../d7/d71/classBloomberg_1_1quantum_1_1Mutex.html" title="Coroutine-compatible implementation of a mutex.">Mutex</a> object which is locked by the current coroutine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Maximum duration for which to wait on this condition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td><a class="el" href="../../d7/d56/classBloomberg_1_1quantum_1_1Function.html" title="Similar implementation to std::function except that it allows capture of non-copyable types.">Function</a> or functor to be tested as exit condition of the endless while loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mutex was acquired before 'time' expired, otherwise the predicate result after timeout. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be called from a coroutine. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d6/db9/namespaceBloomberg.html">Bloomberg</a></li><li class="navelem"><a class="el" href="../../dc/d48/namespaceBloomberg_1_1quantum.html">quantum</a></li><li class="navelem"><a class="el" href="../../da/d9d/classBloomberg_1_1quantum_1_1ConditionVariable.html">ConditionVariable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
